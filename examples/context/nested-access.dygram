machine "Nested Attribute Access Patterns"

// This example demonstrates accessing nested attributes in context nodes
// using template variables and dot notation

// Pattern 1: Simple Nested Context
context appConfig {
    database {
        host<string>: "localhost";
        port<number>: 5432;
        name<string>: "myapp_db";
    }
    api {
        endpoint<string>: "https://api.example.com";
        timeout<number>: 5000;
        retries<number>: 3;
    }
}

task connectDatabase "Connect to Database" {
    // Access nested database configuration
    prompt: "Connect to database at {{appConfig.database.host}}:{{appConfig.database.port}}/{{appConfig.database.name}}";
}

task callAPI "Call API" {
    // Access nested API configuration
    prompt: "Call API at {{appConfig.api.endpoint}} with timeout {{appConfig.api.timeout}}ms and {{appConfig.api.retries}} retries";
}

connectDatabase --> appConfig;
callAPI --> appConfig;

// Pattern 2: Deep Nesting (3+ levels)
context systemConfig {
    services {
        authentication {
            oauth {
                clientId<string>: "client123";
                clientSecret<string>: "secret456";
                authUrl<string>: "https://auth.example.com/oauth";
            }
            jwt {
                secret<string>: "jwt_secret";
                expiresIn<number>: 3600;
            }
        }
        storage {
            s3 {
                bucket<string>: "my-bucket";
                region<string>: "us-east-1";
                accessKey<string>: "AKIAIOSFODNN7EXAMPLE";
            }
        }
    }
}

task authenticateUser "Authenticate User" {
    // Access deeply nested OAuth configuration
    prompt: "Authenticate using OAuth at {{systemConfig.services.authentication.oauth.authUrl}} with client {{systemConfig.services.authentication.oauth.clientId}}";
}

task uploadFile "Upload File" {
    // Access nested S3 configuration
    prompt: "Upload to S3 bucket {{systemConfig.services.storage.s3.bucket}} in {{systemConfig.services.storage.s3.region}}";
}

authenticateUser --> systemConfig;
uploadFile --> systemConfig;

// Pattern 3: Mixed Nesting with Arrays
context featureFlags {
    features {
        beta<Array<string>>: ["feature1", "feature2"];
        experimental<Array<string>>: ["feature3"];
    }
    users {
        admins<Array<string>>: ["admin1", "admin2"];
        betaTesters<Array<string>>: ["user1", "user2"];
    }
}

task checkFeatureAccess "Check Feature Access" {
    prompt: "Check if user has access to beta features: {{featureFlags.features.beta}}";
}

checkFeatureAccess --> featureFlags;

// Pattern 4: Multiple Context References
context userContext {
    profile {
        name<string>: "Alice";
        email<string>: "alice@example.com";
    }
    preferences {
        theme<string>: "dark";
        language<string>: "en";
    }
}

context appSettings {
    ui {
        defaultTheme<string>: "light";
        supportedLanguages<Array<string>>: ["en", "es", "fr"];
    }
}

task personalizeUI "Personalize UI" {
    // Access multiple nested contexts
    prompt: "Set up UI for {{userContext.profile.name}} with theme {{userContext.preferences.theme}} (default: {{appSettings.ui.defaultTheme}})";
}

personalizeUI --> userContext;
personalizeUI --> appSettings;

// Pattern 5: Conditional Access Based on Nested Values
init start "Start";
task checkConfig "Check Configuration" {
    prompt: "Validate configuration settings";
}
state configValid "Configuration Valid";
state configInvalid "Configuration Invalid";
task useDefaults "Use Default Configuration" {
    prompt: "Fall back to default configuration";
}
task proceed "Proceed with Task";
state complete "Complete";

start -> checkConfig;
checkConfig -"{{appConfig.database.host}} != null"-> configValid;
checkConfig -"{{appConfig.database.host}} == null"-> configInvalid;
configValid -> proceed;
configInvalid -> useDefaults;
useDefaults -> proceed;
proceed -> complete;

// Pattern 6: Nested Attributes in Task Definitions
task complexTask "Complex Task" {
    config {
        retry {
            maxAttempts<number>: 3;
            backoff<number>: 1000;
        }
        timeout {
            connect<number>: 5000;
            read<number>: 10000;
        }
    }
    metadata {
        version<string>: "1.0.0";
        author<string>: "System";
    }
}

// Pattern 7: Dynamic Path Resolution
context environment {
    development {
        apiUrl<string>: "http://localhost:3000";
        debugMode<boolean>: true;
    }
    production {
        apiUrl<string>: "https://api.production.com";
        debugMode<boolean>: false;
    }
    current<string>: "development";
}

task initEnvironment "Initialize Environment" {
    prompt: "Initialize with environment: {{environment.current}}";
}

task connectToAPI "Connect to API" {
    prompt: "Connect to API based on current environment configuration";
}

initEnvironment --> environment;
connectToAPI --> environment;

// Pattern 8: Nested Context with Type Safety
context typedConfig {
    database {
        connection {
            host<string>: "localhost";
            port<number>: 5432;
            ssl<boolean>: true;
        }
        pool {
            min<number>: 2;
            max<number>: 10;
            idleTimeout<number>: 10000;
        }
    }
}

task validateConnection "Validate Connection" {
    // Type-safe nested access
    prompt: "Validate connection to {{typedConfig.database.connection.host}}:{{typedConfig.database.connection.port}} with SSL: {{typedConfig.database.connection.ssl}}";
}

validateConnection --> typedConfig;

note for appConfig "Nested context access uses dot notation:
{{contextName.level1.level2.attribute}}

Benefits:
- Organized configuration
- Clear hierarchy
- Type safety at each level
- Better maintainability"

note for systemConfig "Deep nesting guidelines:
- Keep to 3-4 levels maximum
- Use meaningful names at each level
- Group related configuration together
- Consider flattening if too deep"

note for personalizeUI "Multiple context references:
- Tasks can reference multiple contexts
- Each reference creates a dependency
- Dependencies are automatically inferred
- Visualized as dashed arrows in diagram"

note for typedConfig "Type safety in nested structures:
- Types are enforced at each nesting level
- Template variables are type-checked
- Validation catches incorrect paths
- IDE/LSP provides autocomplete"
