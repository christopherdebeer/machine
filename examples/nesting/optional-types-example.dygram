machine "Optional Types Example"

// ═══════════════════════════════════════════════════════════════════
// OPTIONAL TYPES - Types can be inferred when not explicitly provided
// ═══════════════════════════════════════════════════════════════════

// ────────────────────────────────────────────────────────────────────
// 1. TASK INFERENCE - Nodes with 'prompt' attribute are inferred as tasks
// ────────────────────────────────────────────────────────────────────

// Explicit task type (traditional approach)
task explicitTask {
    prompt: "Analyze the data";
}

// Inferred task type (prompt attribute makes it a task)
inferredTask {
    prompt: "Transform the results";
}

// Both are functionally equivalent!
note for explicitTask "Traditional explicit task type"
note for inferredTask "Type inferred from 'prompt' attribute - same behavior as explicit task"

// ────────────────────────────────────────────────────────────────────
// 2. CONTEXT INFERENCE - Data nodes are inferred as contexts
// ────────────────────────────────────────────────────────────────────

// Explicit context type
context apiConfig {
    url: "https://api.example.com";
    timeout: 5000;
}

// Inferred context from name pattern (contains "config")
appConfig {
    apiKey: "xxx";
    retries: 3;
}

// Inferred context from data attributes only
settings {
    theme: "dark";
    language: "en";
}

note for apiConfig "Explicit context type"
note for appConfig "Type inferred from name containing 'config'"
note for settings "Type inferred from having only data attributes"

// ────────────────────────────────────────────────────────────────────
// 3. STATE INFERENCE - Simple nodes default to state (control flow)
// ────────────────────────────────────────────────────────────────────

// Explicit state type
state explicitReady "Ready State";

// Inferred state (default for simple nodes)
waiting "Waiting";
processing "Processing";

note for explicitReady "Explicit state type"
note for waiting "Type inferred as state (default for simple nodes)"

// ────────────────────────────────────────────────────────────────────
// 4. TOOL INFERENCE - Nodes with schema-like attributes are inferred as tools
// ────────────────────────────────────────────────────────────────────

// Explicit tool type
tool explicitCalculator {
    input: "{ x: number, y: number }";
    output: "{ result: number }";
}

// Inferred tool from schema attributes
formatter {
    input: "{ data: string }";
    output: "{ formatted: string }";
}

note for explicitCalculator "Explicit tool type"
note for formatter "Type inferred from input/output schema attributes"

// ────────────────────────────────────────────────────────────────────
// 5. INIT INFERENCE - Nodes with no incoming edges can be inferred as init
// ────────────────────────────────────────────────────────────────────

// Explicit init type
init start "Entry Point";

// Note: Init inference requires graph analysis, so explicit type is recommended
// for clarity. However, the system can infer init from graph structure.

// ────────────────────────────────────────────────────────────────────
// 6. MIXED USAGE - Explicit and inferred types work together seamlessly
// ────────────────────────────────────────────────────────────────────

state Pipeline {
    // Explicit types
    task validateExplicit {
        prompt: "Validate input";
    }

    // Inferred types (same behavior)
    validate {
        prompt: "Validate input";
    }

    transform {
        prompt: "Transform data";
    }

    intermediate "Processing"; // Inferred as state

    store {
        prompt: "Store results";
    }

    // Workflow
    validate -> transform -> intermediate -> store;
}

// ────────────────────────────────────────────────────────────────────
// 7. CONTEXT INHERITANCE WITH INFERRED TYPES
// ────────────────────────────────────────────────────────────────────

// Inferred context from name
globalConfig {
    environment: "production";
}

state DataPipeline {
    // These tasks automatically inherit read access to globalConfig
    extract {
        prompt: "Extract data from {{ globalConfig.environment }}";
    }

    processData { // "Data" in name, but has prompt → inferred as task (priority)
        prompt: "Process extracted data";
    }
}

DataPipeline -reads-> globalConfig;

// ────────────────────────────────────────────────────────────────────
// 8. EXPLICIT TYPE OVERRIDES INFERENCE
// ────────────────────────────────────────────────────────────────────

// Force a node to be a state even though it has data-like name
state userData {
    // This is a control flow state, not a context
    // Explicit type overrides name-based inference
}

// ────────────────────────────────────────────────────────────────────
// KEY BENEFITS OF OPTIONAL TYPES
// ────────────────────────────────────────────────────────────────────

// 1. LESS CEREMONY: Don't need to specify type when it's obvious
// 2. CLEANER SYNTAX: Focus on attributes, not type declarations
// 3. BACKWARD COMPATIBLE: All explicit types still work
// 4. FLEXIBLE: Mix explicit and inferred types freely
// 5. CLEAR OVERRIDES: Explicit type always wins over inference

// ────────────────────────────────────────────────────────────────────
// INFERENCE PRIORITY (from highest to lowest)
// ────────────────────────────────────────────────────────────────────

// 1. Explicit type (always wins)
// 2. Has 'prompt' attribute → task
// 3. Has schema attributes (input/output/parameters/schema/returns) → tool
// 4. Name matches patterns (context/data/input/output/result/config) OR
//    has only data attributes → context
// 5. No incoming edges + has outgoing edges → init (requires edges)
// 6. Default → state

// ────────────────────────────────────────────────────────────────────
// MAIN WORKFLOW
// ────────────────────────────────────────────────────────────────────

start -> explicitTask -> inferredTask;
inferredTask -> Pipeline;
Pipeline -> waiting -> processing;
