machine "UserWorkflow"

// TODO: Import common modules for reusable states and context nodes.
// import "commonPatterns.dsl";

// -----------------------------
// Context Nodes
// -----------------------------
context userData {
    name<string>: "defaultUser";  // User's name
    score<number>: 0;             // User's score
}

// -----------------------------
// State Definitions
// -----------------------------
init s1 {
    // Initial state for welcoming the user.
}

task s2 {
    // Processing state that might perform validations or calculations.
}

s3 {
    // Error handling state for retries or failure.
}

s4 {
    // Successful branch of processing.
}

s5 {
    // Alternative successful branch.
}

s6 {
    // Final state for cleanup or finishing tasks.
}

// -----------------------------
// Transitions (Edges)
// -----------------------------

// Basic sequential transition.
s1 -> s2;

s2 -"natural language label"-> s3;

// Context edge: Read user name from userData during transition.
s1 -read: userData;-> s2 ;

// Transition with explicit error handling (retry up to 3 times).
s2 -catch: retry;-> s3;

// Context edge: Update the user's score during a transition.
s2 -update: score;-> userData;

// Conditional transition: Only if userData.name equals "start".
s1 -if: 'userData.name == "start"';-> s2;

// Chained transition combining multiple modifiers.
s1 -> s2 -catch-> s3 -"if error unresolved, escalate"-> s4 s5 -timeout: 5000; logLevel: 0;-> s6;

// Event-driven transition: s2 transitions to s4 when event "eventComplete" occurs.
s2 -on: eventComplete;-> s4;

// Weighted transitions from s4, modeling probabilistic outcomes.
s4 -weight: 0.7;-> s6;
s4 -weight: 0.3;-> s3;

// Data transformation edge: Apply a function to transform data during the transition.
s5 -transform: '(x => x * 2)';-> s6;

// Asynchronous transition: s2 triggers s4 via an external event.
s2 => s4;

// Context edges: Explicitly read from and update context nodes.
s2 -read: name;-> userData;
s2 -update: score;-> userData;


// parallel and map

s1 s2 -> s3;


s3 -> s4 s5;


s1 s2 => s3 s4;