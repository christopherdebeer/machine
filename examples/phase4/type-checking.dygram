machine "Phase 4: Type Checking Examples"

// ========== Valid Type Checking ==========

task validTypes {
    // Primitive types
    name<string>: "DyGram";
    count<number>: 42;
    enabled<boolean>: true;

    // Generic types
    response<Promise<Response>>: "pending";
    users<Array<User>>: [];
    cache<Map<string, any>>: [];

    // Nested generics
    asyncData<Promise<Array<Record>>>: "loading";

    // Optional types
    optionalValue<string?>: null;
}

// ========== Type Inference ==========

task typeInference {
    // Types inferred automatically
    inferredString: "Hello";        // Inferred as string
    inferredNumber: 123;            // Inferred as number
    inferredBoolean: false;         // Inferred as boolean
    inferredArray: ["a", "b", "c"]; // Inferred as Array<string>
}

// ========== Type Compatibility ==========

context apiConfig {
    baseUrl<string>: "https://api.example.com";
    timeout<number>: 5000;
    retries<number>: 3;
}

task apiCall {
    // Valid template references with compatible types
    url<string>: "{{ apiConfig.baseUrl }}";
    maxRetries<number>: 5;
}

// ========== Complex Generic Types ==========

task dataProcessing {
    // Map with complex value type
    userCache<Map<string, User>>: [];

    // Promise with nested generics
    fetchUsers<Promise<Array<User>>>: "pending";

    // Multiple generic parameters
    transformer<Function<Input, Output>>: null;
}

// ========== Edge Cases ==========

task edgeCases {
    // Empty arrays (type: Array<any>)
    emptyArray<Array<any>>: [];

    // Any type (accepts anything)
    flexible<any>: "can be anything";
}
