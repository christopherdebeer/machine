machine "Error Handling Patterns"

// This example demonstrates common error handling patterns in DyGram

// Pattern 1: Try-Catch-Finally Pattern
init start "Start Process";
task mainTask "Main Task" {
    prompt: "Execute main business logic";
}
state error "Error State";
task errorHandler "Error Handler" {
    prompt: "Handle and log error";
}
task cleanup "Cleanup" {
    prompt: "Cleanup resources";
}
state complete "Complete";

start -> mainTask;
mainTask -"success"-> cleanup;
mainTask -"error"-> error;
error -> errorHandler;
errorHandler -> cleanup;
cleanup -> complete;

// Pattern 2: Retry with Exponential Backoff
context retryConfig {
    maxRetries<number>: 3;
    baseDelay<number>: 1000;
    maxDelay<number>: 10000;
}

task apiCall "API Call" @Async {
    prompt: "Call external API";
    retryCount<number>: 0;
}
task retryHandler "Retry Handler" {
    prompt: "Calculate backoff and retry";
}
state maxRetriesReached "Max Retries Reached";

apiCall -"failure"-> retryHandler;
retryHandler -"retries < maxRetries"-> apiCall;
retryHandler -"retries >= maxRetries"-> maxRetriesReached;
apiCall --> retryConfig;
retryHandler --> retryConfig;

// Pattern 3: Circuit Breaker Pattern
context circuitBreakerState {
    state<string>: "CLOSED";
    failureCount<number>: 0;
    threshold<number>: 5;
    timeout<number>: 30000;
}

task protectedCall "Protected Call" {
    prompt: "Call with circuit breaker protection";
}
state circuitOpen "Circuit Open";
task waitForTimeout "Wait for Timeout" {
    prompt: "Wait before attempting to close circuit";
}
state halfOpen "Half Open";

protectedCall -"success"-> cleanup;
protectedCall -"failure && count < threshold"-> protectedCall;
protectedCall -"failure && count >= threshold"-> circuitOpen;
circuitOpen -> waitForTimeout;
waitForTimeout -"timeout expired"-> halfOpen;
halfOpen -"probe success"-> protectedCall;
halfOpen -"probe failure"-> circuitOpen;

// Pattern 4: Fallback Pattern
task primaryService "Primary Service" @Critical {
    prompt: "Call primary service";
}
task secondaryService "Secondary Service" {
    prompt: "Call secondary/fallback service";
}
task cacheService "Cache Service" {
    prompt: "Return cached data";
}
task defaultResponse "Default Response" {
    prompt: "Return default/safe response";
}

primaryService -"success"-> complete;
primaryService -"failure"-> secondaryService;
secondaryService -"success"-> complete;
secondaryService -"failure"-> cacheService;
cacheService -"success"-> complete;
cacheService -"failure"-> defaultResponse;
defaultResponse -> complete;

// Pattern 5: Timeout Handling
task longRunningTask "Long Running Task" @Async {
    timeout<number>: 5000;
    prompt: "Execute long operation";
}
state timeout "Timeout Occurred";
task timeoutHandler "Timeout Handler" {
    prompt: "Handle timeout gracefully";
}
task cancelTask "Cancel Task" {
    prompt: "Cancel running operation";
}

longRunningTask -"completed"-> complete;
longRunningTask -"timeout"-> timeout;
timeout -> timeoutHandler;
timeoutHandler -> cancelTask;
cancelTask -> complete;

// Pattern 6: Compensating Transactions (Saga Pattern)
task beginTransaction "Begin Transaction";
task step1 "Execute Step 1";
task step2 "Execute Step 2";
task step3 "Execute Step 3";
task commitTransaction "Commit Transaction";

// Compensation tasks
task compensateStep3 "Compensate Step 3";
task compensateStep2 "Compensate Step 2";
task compensateStep1 "Compensate Step 1";
task rollbackTransaction "Rollback Transaction";

// Happy path
beginTransaction -> step1;
step1 -> step2;
step2 -> step3;
step3 -> commitTransaction;
commitTransaction -> complete;

// Failure and compensation path
step3 -"failure"-> compensateStep3;
compensateStep3 -> compensateStep2;
step2 -"failure"-> compensateStep2;
compensateStep2 -> compensateStep1;
step1 -"failure"-> compensateStep1;
compensateStep1 -> rollbackTransaction;
rollbackTransaction -> error;

// Pattern 7: Dead Letter Queue
task messageProcessor "Message Processor" {
    prompt: "Process message from queue";
}
task deadLetterQueue "Dead Letter Queue" {
    prompt: "Move failed message to DLQ";
}
task alerting "Alerting Service" {
    prompt: "Send alert for DLQ message";
}

messageProcessor -"success"-> complete;
messageProcessor -"permanent failure"-> deadLetterQueue;
deadLetterQueue -> alerting;
alerting -> complete;

// Pattern 8: Validation with Detailed Errors
task validateInput "Validate Input" {
    prompt: "Validate incoming data";
}
state validationError "Validation Error";
task formatValidationError "Format Validation Error" {
    prompt: "Format user-friendly error message";
}
task logValidationError "Log Validation Error" {
    prompt: "Log validation error details";
}

validateInput -"valid"-> mainTask;
validateInput -"invalid"-> validationError;
validationError -> formatValidationError;
validationError -> logValidationError;
formatValidationError -> complete;

note for errorHandler "Error handlers should:
1. Log error details with context
2. Update metrics/monitoring
3. Determine if error is recoverable
4. Take appropriate action (retry, fallback, or fail)"

note for retryHandler "Retry logic should:
1. Implement exponential backoff
2. Add jitter to prevent thundering herd
3. Respect max retry limits
4. Consider idempotency"

note for protectedCall "Circuit breaker states:
- CLOSED: Normal operation, requests pass through
- OPEN: Too many failures, requests rejected immediately
- HALF_OPEN: Testing if service recovered"
