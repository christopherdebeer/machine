import { PageLayout } from '../../src/components/PageLayout';
import { ExampleLoader } from '../../src/components/ExampleLoader';

<PageLayout title="Rails-Based Architecture Examples">


This directory contains examples demonstrating DyGram's Rails-Based Architecture execution model.

## What is Rails-Based Architecture?

The Rails-Based Architecture treats your machine definition as "rails" that guide a single Claude agent through a workflow. Some transitions happen automatically (deterministic paths), while others require the agent to make complex decisions.

**Key Concepts:**
- ðŸ›¤ï¸ **Rails** = Your machine structure defines the tracks
- ðŸ¤– **Single Agent** = One agent rides those tracks with phase-specific context
- âš¡ **Automated Transitions** = Deterministic paths execute without LLM calls
- ðŸ§  **Agent Decisions** = Complex branching requires agent reasoning
- ðŸ”§ **Meta-Programming** = Agent can construct tools and modify the machine

## Examples

### 1. `auto-transitions.mach`
**Demonstrates:** Automated vs agent-controlled transitions

Shows how state nodes, `@auto` edges, and simple conditions automatically transition without invoking the agent, improving efficiency.

**Key Features:**
- State nodes with automatic transitions
- `@auto` annotation for forced automation
- Conditional automatic transitions (`when:`, `unless:`)
- Agent-controlled branching decisions

**Run:**
```bash
dygram exec examples/rails/auto-transitions.mach
```

---

### 2. `dynamic-tool-construction.mach`
**Demonstrates:** Dynamic tool creation by the agent

Shows how an agent with `meta: true` can construct new tools when they don't exist in the codebase.

**Key Features:**
- `meta: true` enables meta-programming
- `construct_tool` creates tools dynamically
- Three implementation strategies: agent-backed, code-generation, composition
- Tool registry tracking

**Run:**
```bash
dygram exec examples/rails/dynamic-tool-construction.mach
```

---

### 3. `self-improving-pipeline.mach`
**Demonstrates:** Complete meta-programming workflow

The canonical Rails-Based Architecture example showing a pipeline that constructs tools, uses them, reviews them, improves them, and runs again with better tools.

**Key Features:**
- Tool construction when capabilities missing
- Tool review and improvement proposals
- Iterative refinement loop
- Quality-based automatic transitions
- Full meta-programming lifecycle

**Run:**
```bash
dygram exec examples/rails/self-improving-pipeline.mach
```

---

### 4. `phase-specific-context.mach`
**Demonstrates:** Permission-based context access

Shows how agents receive only relevant context at each node, based on edge permissions. Demonstrates security through least-privilege access.

**Key Features:**
- Edge-based permissions (`-reads->`, `-writes->`, `-stores->`)
- Field-level access control (`-read: field1,field2->`)
- Context isolation for security
- Phase-specific tool availability

**Run:**
```bash
dygram exec examples/rails/phase-specific-context.mach
```

---

### 5. `tool-review-improvement.mach`
**Demonstrates:** Tool review and improvement workflow

Shows how an agent can inspect existing tool implementations, identify deficiencies, propose improvements, and apply them.

**Key Features:**
- `list_available_tools` with source code inspection
- `propose_tool_improvement` for enhancement suggestions
- Iterative improvement loop
- Tool evolution over execution

**Run:**
```bash
dygram exec examples/rails/tool-review-improvement.mach
```

---

## Learning Path

**Beginner:**
1. Start with `auto-transitions.mach` to understand the rails pattern
2. Move to `phase-specific-context.mach` to see permission model

**Intermediate:**
3. Study `dynamic-tool-construction.mach` for meta-programming basics
4. Explore `tool-review-improvement.mach` for tool evolution

**Advanced:**
5. Master `self-improving-pipeline.mach` for complete meta-programming

## Execution Requirements

All examples require:
- **API Key**: Set `ANTHROPIC_API_KEY` environment variable
- **Model**: Uses `claude-sonnet-4-5` by default

```bash
export ANTHROPIC_API_KEY=your_key_here
dygram exec examples/rails/self-improving-pipeline.mach
```

## Execution History

After running any example, check `execution-history.json` for:
- Complete execution trace
- Agent conversation history
- Tools used at each step
- Mutations and tool constructions
- Token usage statistics

```bash
cat execution-history.json | jq
```

## Interactive Playground

Try these examples in the interactive playground:
1. Open http://localhost:5173/playground.html (or your deployed URL)
2. Paste an example machine
3. Configure API key in settings
4. Use execution controls:
   - â–¶ï¸ **Execute**: Run to completion
   - â­ï¸ **Step**: Debug step-by-step
   - â¹ï¸ **Stop**: Halt execution
   - ðŸ”„ **Reset**: Clear state

## Key Patterns

### Automated Transition Pattern
```machine
State idle;
State ready;

// Automatic - no agent invocation
idle -@auto-> ready;
```

### Agent Decision Pattern
```machine
Task analyze {
    prompt: "Analyze and decide next step";
};

// Agent chooses via transition tool
analyze -> success, retry, abort;
```

### Context Permission Pattern
```machine
context secrets {
    apiKey<string>: "secret";
};

// Only process can access secrets
process -reads-> secrets;
```

### Tool Construction Pattern
```machine
Task process {
    meta: true;
    prompt: "Process data. Construct tools if needed.";
};

process -writes-> toolRegistry;
```

### Tool Improvement Pattern
```machine
Task review {
    meta: true;
    prompt: "Review tools and propose improvements";
};

review -reads-> toolRegistry;
review -writes-> toolRegistry;
```

## See Also

- [Rails-Based Architecture Documentation](../../docs/RailsBasedArchitecture.mdx)
- [Meta-Programming Guide](../../docs/meta-programming.md) (future)
- [LLM Client Usage](../../docs/LlmClientUsage.mdx)
- [Runtime & Evolution](../../docs/RuntimeAndEvolution.mdx)

## Contributing

Have a Rails-Based Architecture pattern to share? Submit a PR with:
1. A new `.mach` file demonstrating the pattern
2. Comprehensive inline comments explaining behavior
3. Update this README with the example description
4. Add test coverage if applicable


</PageLayout>