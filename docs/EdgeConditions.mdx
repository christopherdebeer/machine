# Edge Conditions

DyGram supports conditional edge transitions using the Common Expression Language (CEL) for safe, sandboxed expression evaluation.

## Overview

Edge conditions allow you to control when a transition should occur based on runtime state, attributes, or other variables. Conditions are evaluated using CEL, which provides a secure alternative to JavaScript `eval()`.

## Basic Syntax

Conditions can be specified on edges using labels with the `if:`, `when:`, or `unless:` keywords:

```dygram
machine "Conditional Transitions"

state idle;
state processing;
state complete;

// Simple condition
idle -if: '(errorCount == 0)';-> processing;

// Using "when" (same as "if")
processing -when: '(status == "ready")';-> complete;

// Using "unless" (negated condition)
processing -unless: '(errorCount > 0)';-> complete;
```

## CEL Expression Syntax

### Comparison Operators

CEL uses standard comparison operators:

- `==` - Equal to (note: use `==`, not `===`)
- `!=` - Not equal to (note: use `!=`, not `!==`)
- `<` - Less than
- `>` - Greater than
- `<=` - Less than or equal to
- `>=` - Greater than or equal to

```dygram
// Numeric comparisons
retry -if: '(retryCount < maxRetries)';-> task;
task -if: '(errorCount >= threshold)';-> failed;

// String comparisons
task -if: '(status == "pending")';-> processing;
processing -if: '(activeState != "idle")';-> complete;
```

### Logical Operators

Combine conditions using logical operators:

- `&&` - Logical AND
- `||` - Logical OR
- `!` - Logical NOT

```dygram
// AND condition
task -if: '(retryCount < maxRetries && circuitState == "CLOSED")';-> retry;

// OR condition
task -if: '(errorCount > 5 || timeout == true)';-> failed;

// NOT condition
task -unless: '(isValid)';-> validation;
```

### Parentheses

Use parentheses to group expressions and control evaluation order:

```dygram
task -if: '((retryCount < maxRetries) && (errorCount > 0))';-> retry;
task -if: '((status == "ready") || (force == true)) && (enabled == true)';-> process;
```

## Variable Access

### Built-in Variables

DyGram provides several built-in variables:

- `errorCount` - Number of errors that have occurred
- `errors` - Alias for `errorCount` (backward compatibility)
- `activeState` - Name of the current active state

```dygram
// Using errorCount
task -if: '(errorCount > 0)';-> errorHandler;

// Using activeState
task -if: '(activeState == "processing")';-> continue;
```

### Attribute Access

Access node attributes using dot notation:

```dygram
machine "Attribute Access"

context config {
    maxRetries<number>: 3;
    timeout<number>: 5000;
    debug<boolean>: false;
}

task apiCall {
    retryCount<number>: 0;
}

// Access flat attributes
apiCall -if: '(retryCount < maxRetries)';-> retry;

// Access nested attributes (from context)
apiCall -if: '(config.debug == true)';-> debugMode;
```

### Template Variable Syntax

You can use template variable syntax `{{ nodeName.attributeName }}` which is automatically converted to CEL syntax. This syntax supports full CEL expressions, not just property access:

```dygram
machine "Template Variables"

context userData {
    name<string>: "start";
    priority<number>: 5;
}

task validation;
state processing;

// Template syntax (automatically converted to CEL)
validation -if: '({{ userData.name }} == "start")';-> processing;
validation -if: '({{ userData.priority }} > 3)';-> processing;

// Template variables also work in prompts and attributes
task greet {
    prompt: "Welcome, {{ userData.name }}! Your priority level is {{ userData.priority }}.";
}
```

**Note:** Template variables use CEL's native object navigation, which means:
- Nested properties work seamlessly: `{{ config.database.host }}`
- Full CEL expressions are supported: `{{ userData.priority + 1 }}`
- All CEL operators and functions are available within templates

## Real-World Examples

### Retry Logic

```dygram
machine "Retry Pattern"

context retryConfig {
    maxRetries<number>: 3;
    baseDelay<number>: 1000;
}

task apiCall {
    retryCount<number>: 0;
}

task retryHandler;
state failed;
state success;

// Retry if under limit
apiCall -if: '(retryCount < maxRetries)';-> retryHandler;

// Fail if limit exceeded
apiCall -if: '(retryCount >= maxRetries)';-> failed;
```

### Circuit Breaker Pattern

```dygram
machine "Circuit Breaker"

context circuitBreakerState {
    state<string>: "CLOSED";
    failureCount<number>: 0;
    threshold<number>: 5;
}

task protectedCall;
state circuitOpen;
state success;

// Open circuit if threshold exceeded
protectedCall -if: '(failureCount >= threshold && circuitBreakerState.state == "CLOSED")';-> circuitOpen;

// Allow call if circuit closed
protectedCall -if: '(circuitBreakerState.state == "CLOSED")';-> success;
```

### State-Based Routing

```dygram
machine "State Routing"

context request {
    priority<string>: "high";
    type<string>: "urgent";
}

task router;
task highPriorityHandler;
task normalHandler;

// Route based on multiple conditions
router -if: '(request.priority == "high" && request.type == "urgent")';-> highPriorityHandler;
router -if: '(request.priority != "high")';-> normalHandler;
```

## Migration from JavaScript eval()

Prior to version 0.3.5, DyGram used JavaScript `eval()` for condition evaluation, which posed security risks. The CEL integration provides a safe, sandboxed alternative.

### Key Differences

1. **Equality Operators**: Use `==` and `!=` instead of `===` and `!==`
2. **Variable Access**: Variables are accessed directly by name (no need for special syntax)
3. **Sandboxed**: No access to JavaScript globals or functions
4. **Type Safety**: CEL enforces type checking

### Automatic Conversion

The executor automatically converts JavaScript-style operators to CEL equivalents:

```dygram
// Old JavaScript-style (still works - automatically converted)
task -if: '(count === 5)';-> next;

// New CEL-style (preferred)
task -if: '(count == 5)';-> next;
```

## Best Practices

1. **Keep Conditions Simple**: Complex conditions can be hard to debug. Consider breaking complex logic into multiple nodes.

2. **Use Descriptive Variable Names**: Make conditions self-documenting.

3. **Leverage Context Nodes**: Store configuration and state in context nodes for better organization.

4. **Test Edge Cases**: Ensure your conditions handle boundary cases correctly.

5. **Use Parentheses**: Even when not strictly necessary, parentheses improve readability.

## Error Handling

If a condition fails to evaluate (syntax error, undefined variable, etc.), the condition returns `false` by default (fail-safe behavior). This prevents unexpected transitions when conditions are malformed.

```dygram
// If this condition has an error, it will return false
task -if: '(invalidSyntax >)';-> next;  // Won't transition due to error
```

## See Also

- [Advanced Features](./AdvancedFeatures.mdx)
- [Syntax Guide](./SyntaxGuide.mdx)
- [Error Handling Examples](../examples/advanced/error-handling.dygram)
- [CEL Language Specification](https://github.com/google/cel-spec)
