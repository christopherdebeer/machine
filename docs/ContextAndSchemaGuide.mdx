import { Layout } from '../src/components/Layout';
import { CodeEditor } from '../src/components/CodeEditor';

<Layout>

# Context and Schema Management Guide

## Overview

The machine language now supports enhanced context value management and schema validation, enabling tasks to generate specific values and store or pass them for later tasks.

## Key Features

### 1. Context Nodes with Typed Attributes

Context nodes can declare typed attributes that serve as data containers:

<CodeEditor
    initialCode={`context output {
  value<string>: "";
  metadata<object>: "{}";
  count<number>: 0;
  isComplete<boolean>: false;
};`}
    language="dygram"
    readOnly
    height="140px"
/>

**Supported Types:**
- `string` - Text values
- `number` - Numeric values
- `boolean` - True/false values
- `object` - JSON objects (stored as strings)
- `array` - JSON arrays (stored as strings)

### 2. Context Management Tools

Tasks now have access to context management tools:

#### `set_context_value`
Sets a value in a context node attribute with type validation:

<CodeEditor
    initialCode={`set_context_value(nodeName: "output", attributeName: "value", value: "Hello World")`}
    language="typescript"
    readOnly
    height="60px"
/>

#### `get_context_value`
Retrieves a value from a context node attribute:

<CodeEditor
    initialCode={`get_context_value(nodeName: "output", attributeName: "value")`}
    language="typescript"
    readOnly
    height="60px"
/>

#### `list_context_nodes`
Lists all context nodes and their current values:

<CodeEditor
    initialCode={`list_context_nodes()`}
    language="typescript"
    readOnly
    height="60px"
/>

### 3. Template Variable Resolution

Tasks can reference context values using template syntax:

<CodeEditor
    initialCode={`Task processData {
  prompt: "The stored value is {{output.value}}. Process this data and create a summary.";
};`}
    language="dygram"
    readOnly
    height="100px"
/>

**Template Syntax:**
- `{{nodeName.attributeName}}` - References a context node's attribute value
- Values are resolved at runtime using CEL (Common Expression Language)
- Supports nested object property access (e.g., `{{config.database.host}}`)
- Can include CEL expressions (e.g., `{{count + 1}}`, `{{name + " " + surname}}`)
- Safe, sandboxed evaluation prevents security risks

### 4. Enhanced Execution Flow

The execution system now:
- **Validates types** when setting context values
- **Resolves template variables** in prompts before LLM execution
- **Tracks context mutations** in execution history
- **Preserves context state** across task transitions

## Example Workflows

### Basic Context Storage

<CodeEditor
    initialCode={`machine "Data Processing"

Task generate {
  meta: true;
  prompt: "Generate a random number and store it using set_context_value";
};

context data {
  value<number>: 0;
};

Task process {
  prompt: "The number is {{data.value}}. Calculate its square.";
};

generate -stores-> data;
data --> process;`}
    language="dygram"
    readOnly
    height="320px"
/>

### Multi-Context Pipeline

<CodeEditor
    initialCode={`machine "Analysis Pipeline"

Task analyze {
  prompt: "Analyze input data and store results in multiple contexts";
};

context metrics {
  count<number>: 0;
  average<number>: 0.0;
};

context summary {
  text<string>: "";
  confidence<number>: 0.0;
};

Task report {
  prompt: "Create report: {{metrics.count}} items, avg {{metrics.average}}, summary: {{summary.text}}";
};

analyze -populates-> metrics;
analyze -creates-> summary;
metrics --> report;
summary --> report;`}
    language="dygram"
    readOnly
    height="420px"
/>

## Implementation Details

### Type Validation
- Values are validated against declared types when using `set_context_value`
- Type mismatches throw descriptive errors
- Custom types are allowed (validation passes through)

### Value Serialization
- String values stored directly
- Complex values (objects, arrays) serialized as JSON strings
- Values parsed back to original types when retrieved

### Template Resolution
- Happens before prompt compilation
- Supports dot notation for attribute access
- Graceful fallback if template variables can't be resolved

## Benefits

1. **Structured Data Flow**: Clear input/output contracts between tasks
2. **Type Safety**: Runtime validation prevents type errors
3. **Reusable Context**: Values can be shared across multiple tasks
4. **Dynamic Prompts**: Template variables enable context-aware task execution
5. **Execution Tracking**: Full audit trail of context value changes

## Migration from Previous Version

**Before:**

<CodeEditor
    initialCode={`Task process {
  prompt: "write a haiku";
};
// Output only stored in execution history`}
    language="dygram"
    readOnly
    height="100px"
/>

**After:**

<CodeEditor
    initialCode={`Task process {
  meta: true;
  prompt: "write a haiku and store it using set_context_value";
};

context output {
  haiku<string>: "";
};
// Output properly stored in context node for reuse`}
    language="dygram"
    readOnly
    height="160px"
/>

This enhanced system enables more sophisticated workflows where tasks can build upon each other's outputs in a structured, type-safe manner.

</Layout>
