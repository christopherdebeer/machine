import { test, expect } from '@playwright/test';
import { EmptyFileSystem } from "langium";
import { parseHelper } from "langium/test";
import { createMachineServices } from "../../src/language/machine-module.js";
import { Machine, isMachine } from "../../src/language/generated/ast.js";
import { generateMermaid } from "../../src/language/generator/generator.js";
import * as fs from "node:fs";
import * as path from "node:path";

/**
 * End-to-End Mermaid Rendering Tests
 *
 * This test suite validates that Mermaid diagrams generated by DyGram
 * can actually be rendered in a browser environment. This catches issues
 * that syntax validation alone cannot detect.
 *
 * The tests:
 * 1. Load example DyGram files
 * 2. Generate Mermaid diagrams
 * 3. Render them in a real browser using Playwright
 * 4. Validate successful SVG generation
 * 5. Capture any rendering errors
 */

interface RenderResult {
    testName: string;
    success: boolean;
    errorMessage?: string;
    svgGenerated: boolean;
    mermaidDiagram: string;
}

class E2ERenderReporter {
    private results: RenderResult[] = [];
    private outputDir = path.join(process.cwd(), 'test-output', 'e2e-render');

    constructor() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    addResult(result: RenderResult): void {
        this.results.push(result);
    }

    generateReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.success).length;
        const failed = total - passed;

        let report = `# E2E Mermaid Rendering Test Report\n\n`;
        report += `## Summary\n`;
        report += `- Total Tests: ${total}\n`;
        report += `- Successfully Rendered: ${passed}\n`;
        report += `- Failed to Render: ${failed}\n`;
        report += `- Success Rate: ${((passed / total) * 100).toFixed(2)}%\n\n`;

        const failedResults = this.results.filter(r => !r.success);
        if (failedResults.length > 0) {
            report += `## Failed Renders\n\n`;
            failedResults.forEach(r => {
                report += `### ${r.testName}\n`;
                report += `**Error:** ${r.errorMessage}\n`;
                report += `**SVG Generated:** ${r.svgGenerated ? 'Yes' : 'No'}\n\n`;
                report += `**Mermaid Diagram:**\n\`\`\`mermaid\n${r.mermaidDiagram}\n\`\`\`\n\n`;
            });
        }

        return report;
    }

    generateHtmlReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.success).length;
        const failed = total - passed;
        const successRate = ((passed / total) * 100).toFixed(2);

        let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Rendering Test Report - DyGram</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 2rem; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 2rem; }
        h1 { color: #667eea; margin-bottom: 0.5rem; }
        .subtitle { color: #666; margin-bottom: 2rem; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem; }
        .stat-card { padding: 1.5rem; border-radius: 6px; text-align: center; }
        .stat-card.total { background: #e3f2fd; }
        .stat-card.passed { background: #e8f5e9; }
        .stat-card.failed { background: #ffebee; }
        .stat-value { font-size: 2.5rem; font-weight: bold; }
        .stat-label { color: #666; font-size: 0.875rem; margin-top: 0.5rem; }
        .test-list { margin-top: 2rem; }
        .test-item { border: 1px solid #e0e0e0; border-radius: 4px; margin-bottom: 1rem; overflow: hidden; }
        .test-header { padding: 1rem; background: #fafafa; display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .test-header:hover { background: #f5f5f5; }
        .test-name { font-weight: 600; }
        .test-status { padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.875rem; font-weight: 600; }
        .test-status.passed { background: #4caf50; color: white; }
        .test-status.failed { background: #f44336; color: white; }
        .test-details { padding: 1rem; display: none; background: white; border-top: 1px solid #e0e0e0; }
        .test-details.active { display: block; }
        .error-message { color: #d32f2f; padding: 1rem; background: #ffebee; border-radius: 4px; margin-top: 1rem; }
    </style>
    <script>
        function toggleDetails(id) {
            const details = document.getElementById(id);
            details.classList.toggle('active');
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>üé≠ E2E Rendering Test Report</h1>
        <p class="subtitle">Browser-based Mermaid diagram rendering validation</p>

        <div class="summary">
            <div class="stat-card total">
                <div class="stat-value">${total}</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card passed">
                <div class="stat-value">${passed}</div>
                <div class="stat-label">Rendered Successfully</div>
            </div>
            <div class="stat-card failed">
                <div class="stat-value">${failed}</div>
                <div class="stat-label">Failed to Render</div>
            </div>
            <div class="stat-card total">
                <div class="stat-value">${successRate}%</div>
                <div class="stat-label">Success Rate</div>
            </div>
        </div>

        <div class="test-list">
            <h2>Test Results</h2>`;

        this.results.forEach((result, index) => {
            const detailsId = `details-${index}`;
            html += `
            <div class="test-item">
                <div class="test-header" onclick="toggleDetails('${detailsId}')">
                    <span class="test-name">${result.testName}</span>
                    <span class="test-status ${result.success ? 'passed' : 'failed'}">${result.success ? 'RENDERED' : 'FAILED'}</span>
                </div>
                <div class="test-details" id="${detailsId}">
                    <p><strong>SVG Generated:</strong> ${result.svgGenerated ? 'Yes ‚úì' : 'No ‚úó'}</p>`;

            if (result.errorMessage) {
                html += `<div class="error-message">
                    <strong>Error:</strong> ${result.errorMessage}
                </div>`;
            }

            html += `
                </div>
            </div>`;
        });

        html += `
        </div>
    </div>
</body>
</html>`;

        return html;
    }

    writeReport(): void {
        const report = this.generateReport();
        const htmlReport = this.generateHtmlReport();

        fs.writeFileSync(path.join(this.outputDir, 'RENDER-REPORT.md'), report);
        fs.writeFileSync(path.join(this.outputDir, 'index.html'), htmlReport);

        console.log(`\nüé≠ E2E render test report written to: ${path.join(this.outputDir, 'RENDER-REPORT.md')}`);
        console.log(`üåê HTML report available at: ${path.join(this.outputDir, 'index.html')}\n`);
    }
}

// Set up Langium services
let services: ReturnType<typeof createMachineServices>;
let parse: ReturnType<typeof parseHelper<Machine>>;
const reporter = new E2ERenderReporter();

test.beforeAll(async () => {
    services = createMachineServices(EmptyFileSystem);
    parse = parseHelper<Machine>(services.Machine);
});

test.afterAll(async () => {
    reporter.writeReport();
});

// Helper function to test Mermaid rendering in browser
async function testMermaidRendering(
    page: any,
    testName: string,
    dygramSource: string
): Promise<RenderResult> {
    const result: RenderResult = {
        testName,
        success: false,
        svgGenerated: false,
        mermaidDiagram: ''
    };

    try {
        // Parse the DyGram source
        const document = await parse(dygramSource);

        if (document.parseResult.parserErrors.length > 0) {
            result.errorMessage = `Parse errors: ${document.parseResult.parserErrors.map(e => e.message).join(', ')}`;
            reporter.addResult(result);
            return result;
        }

        if (!isMachine(document.parseResult.value)) {
            result.errorMessage = 'Parsed value is not a Machine';
            reporter.addResult(result);
            return result;
        }

        const machine = document.parseResult.value as Machine;

        // Generate Mermaid diagram
        const mermaidResult = generateMermaid(machine, 'test.mach', undefined);
        result.mermaidDiagram = mermaidResult.content;

        // Create HTML page with Mermaid
        const html = `
<!DOCTYPE html>
<html>
<head>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';

        window.mermaidReady = false;

        mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: 'default'
        });

        window.mermaidReady = true;

        window.renderMermaid = async function(diagram) {
            try {
                const container = document.getElementById('result');
                const { svg } = await mermaid.render('mermaid-diagram', diagram);
                container.innerHTML = svg;

                return {
                    success: true,
                    svgGenerated: !!container.querySelector('svg')
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message || String(error)
                };
            }
        };
    </script>
</head>
<body>
    <div id="result"></div>
</body>
</html>
        `;

        // Navigate to the HTML page
        await page.setContent(html);

        // Wait for Mermaid to be ready
        await page.waitForFunction(() => window.mermaidReady === true, { timeout: 10000 });

        // Render the Mermaid diagram
        const renderResult = await page.evaluate(async (diagram: string) => {
            return await window.renderMermaid(diagram);
        }, result.mermaidDiagram);

        result.success = renderResult.success;
        result.svgGenerated = renderResult.svgGenerated;

        if (!renderResult.success) {
            result.errorMessage = renderResult.error || 'Unknown rendering error';
        }

    } catch (error: any) {
        result.errorMessage = error.message || String(error);
        result.success = false;
    }

    reporter.addResult(result);
    return result;
}

// Helper to load example files
const loadExample = (category: string, filename: string): string => {
    const examplesDir = path.join(process.cwd(), 'examples');
    const filePath = path.join(examplesDir, category, filename);
    return fs.readFileSync(filePath, 'utf-8');
};

// Test suite
test.describe('E2E Mermaid Rendering Tests', () => {
    test('Basic: Minimal Machine', async ({ page }) => {
        const source = loadExample('basic', 'minimal.dygram');
        const result = await testMermaidRendering(page, 'Minimal Machine', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: Empty and Minimal', async ({ page }) => {
        const source = loadExample('basic', 'empty-and-minimal.dygram');
        const result = await testMermaidRendering(page, 'Empty and Minimal', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: Simple Nodes (3)', async ({ page }) => {
        const source = loadExample('basic', 'simple-nodes-3.dygram');
        const result = await testMermaidRendering(page, 'Simple Nodes (3)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: Typed Nodes', async ({ page }) => {
        const source = loadExample('basic', 'typed-nodes.dygram');
        const result = await testMermaidRendering(page, 'Typed Nodes', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: All Node Types', async ({ page }) => {
        const source = loadExample('basic', 'all-node-types.dygram');
        const result = await testMermaidRendering(page, 'All Node Types', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Attributes: Basic Attributes', async ({ page }) => {
        const source = loadExample('attributes', 'basic-attributes.dygram');
        const result = await testMermaidRendering(page, 'Basic Attributes', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Attributes: Deep Attributes', async ({ page }) => {
        const source = loadExample('attributes', 'deep-attributes.dygram');
        const result = await testMermaidRendering(page, 'Deep Attributes', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Basic Edges', async ({ page }) => {
        const source = loadExample('edges', 'basic-edges.dygram');
        const result = await testMermaidRendering(page, 'Basic Edges', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Labeled Edges', async ({ page }) => {
        const source = loadExample('edges', 'labeled-edges.dygram');
        const result = await testMermaidRendering(page, 'Labeled Edges', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Mixed Arrow Types', async ({ page }) => {
        const source = loadExample('edges', 'mixed-arrow-types.dygram');
        const result = await testMermaidRendering(page, 'Mixed Arrow Types', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Quoted Labels', async ({ page }) => {
        const source = loadExample('edges', 'quoted-labels.dygram');
        const result = await testMermaidRendering(page, 'Quoted Labels', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Nested (2 levels)', async ({ page }) => {
        const source = loadExample('nesting', 'nested-2-levels.dygram');
        const result = await testMermaidRendering(page, 'Nested (2 levels)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Nested (3 levels)', async ({ page }) => {
        const source = loadExample('nesting', 'nested-3-levels.dygram');
        const result = await testMermaidRendering(page, 'Nested (3 levels)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Complex Nesting', async ({ page }) => {
        const source = loadExample('nesting', 'complex-nesting.dygram');
        const result = await testMermaidRendering(page, 'Complex Nesting', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Deep Nested (5 levels)', async ({ page }) => {
        const source = loadExample('nesting', 'deep-nested-5-levels.dygram');
        const result = await testMermaidRendering(page, 'Deep Nested (5 levels)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Complex: Complex Machine', async ({ page }) => {
        const source = loadExample('complex', 'complex-machine.dygram');
        const result = await testMermaidRendering(page, 'Complex Machine', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Complex: Unicode Machine', async ({ page }) => {
        const source = loadExample('complex', 'unicode-machine.dygram');
        const result = await testMermaidRendering(page, 'Unicode Machine', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Complex: Context Heavy', async ({ page }) => {
        const source = loadExample('complex', 'context-heavy.dygram');
        const result = await testMermaidRendering(page, 'Context Heavy', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Stress: Large Machine (50 nodes)', async ({ page }) => {
        const source = loadExample('stress', 'large-50-nodes.dygram');
        const result = await testMermaidRendering(page, 'Large Machine (50 nodes)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edge Cases: Special Characters', async ({ page }) => {
        const source = loadExample('edge-cases', 'special-characters.dygram');
        const result = await testMermaidRendering(page, 'Special Characters', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edge Cases: Edge Cases Collection', async ({ page }) => {
        const source = loadExample('edge-cases', 'edge-cases-collection.dygram');
        const result = await testMermaidRendering(page, 'Edge Cases Collection', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: User Onboarding', async ({ page }) => {
        const source = loadExample('workflows', 'user-onboarding.dygram');
        const result = await testMermaidRendering(page, 'User Onboarding', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: Order Processing', async ({ page }) => {
        const source = loadExample('workflows', 'order-processing.dygram');
        const result = await testMermaidRendering(page, 'Order Processing', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: CI/CD Pipeline', async ({ page }) => {
        const source = loadExample('workflows', 'ci-cd-pipeline.dygram');
        const result = await testMermaidRendering(page, 'CI/CD Pipeline', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: Smart Task Prioritizer', async ({ page }) => {
        const source = loadExample('workflows', 'smart-task-prioritizer.dygram');
        const result = await testMermaidRendering(page, 'Smart Task Prioritizer', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: Code Generation Demo', async ({ page }) => {
        const source = loadExample('workflows', 'code-generation-demo.dygram');
        const result = await testMermaidRendering(page, 'Code Generation Demo', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Semantic Nesting Example', async ({ page }) => {
        const source = loadExample('nesting', 'semantic-nesting-example.dygram');
        const result = await testMermaidRendering(page, 'Semantic Nesting Example', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });
});
