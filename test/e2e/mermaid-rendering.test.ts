import { test, expect } from '@playwright/test';
import { EmptyFileSystem } from "langium";
import { parseHelper } from "langium/test";
import { createMachineServices } from "../../src/language/machine-module.js";
import { Machine, isMachine } from "../../src/language/generated/ast.js";
import { generateMermaid } from "../../src/language/generator/generator.js";
import * as fs from "node:fs";
import * as path from "node:path";

/**
 * End-to-End Mermaid Rendering Tests
 *
 * This test suite validates that Mermaid diagrams generated by DyGram
 * can actually be rendered in a browser environment. This catches issues
 * that syntax validation alone cannot detect.
 *
 * The tests:
 * 1. Load example DyGram files
 * 2. Generate Mermaid diagrams
 * 3. Render them in a real browser using Playwright
 * 4. Validate successful SVG generation
 * 5. Capture any rendering errors
 */

interface RenderResult {
    testName: string;
    success: boolean;
    errorMessage?: string;
    svgGenerated: boolean;
    mermaidDiagram: string;
}

class E2ERenderReporter {
    private results: RenderResult[] = [];
    private outputDir = path.join(process.cwd(), 'test-output', 'e2e-render');

    constructor() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    addResult(result: RenderResult): void {
        this.results.push(result);
    }

    generateReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.success).length;
        const failed = total - passed;

        let report = `# E2E Mermaid Rendering Test Report\n\n`;
        report += `## Summary\n`;
        report += `- Total Tests: ${total}\n`;
        report += `- Successfully Rendered: ${passed}\n`;
        report += `- Failed to Render: ${failed}\n`;
        report += `- Success Rate: ${((passed / total) * 100).toFixed(2)}%\n\n`;

        const failedResults = this.results.filter(r => !r.success);
        if (failedResults.length > 0) {
            report += `## Failed Renders\n\n`;
            failedResults.forEach(r => {
                report += `### ${r.testName}\n`;
                report += `**Error:** ${r.errorMessage}\n`;
                report += `**SVG Generated:** ${r.svgGenerated ? 'Yes' : 'No'}\n\n`;
                report += `**Mermaid Diagram:**\n\`\`\`mermaid\n${r.mermaidDiagram}\n\`\`\`\n\n`;
            });
        }

        return report;
    }

    writeReport(): void {
        const report = this.generateReport();
        fs.writeFileSync(path.join(this.outputDir, 'RENDER-REPORT.md'), report);
        console.log(`\nðŸŽ­ E2E render test report written to: ${path.join(this.outputDir, 'RENDER-REPORT.md')}\n`);
    }
}

// Set up Langium services
let services: ReturnType<typeof createMachineServices>;
let parse: ReturnType<typeof parseHelper<Machine>>;
const reporter = new E2ERenderReporter();

test.beforeAll(async () => {
    services = createMachineServices(EmptyFileSystem);
    parse = parseHelper<Machine>(services.Machine);
});

test.afterAll(async () => {
    reporter.writeReport();
});

// Helper function to test Mermaid rendering in browser
async function testMermaidRendering(
    page: any,
    testName: string,
    dygramSource: string
): Promise<RenderResult> {
    const result: RenderResult = {
        testName,
        success: false,
        svgGenerated: false,
        mermaidDiagram: ''
    };

    try {
        // Parse the DyGram source
        const document = await parse(dygramSource);

        if (document.parseResult.parserErrors.length > 0) {
            result.errorMessage = `Parse errors: ${document.parseResult.parserErrors.map(e => e.message).join(', ')}`;
            reporter.addResult(result);
            return result;
        }

        if (!isMachine(document.parseResult.value)) {
            result.errorMessage = 'Parsed value is not a Machine';
            reporter.addResult(result);
            return result;
        }

        const machine = document.parseResult.value as Machine;

        // Generate Mermaid diagram
        const mermaidResult = generateMermaid(machine, 'test.mach', undefined);
        result.mermaidDiagram = mermaidResult.content;

        // Create HTML page with Mermaid
        const html = `
<!DOCTYPE html>
<html>
<head>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';

        window.mermaidReady = false;

        mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: 'default'
        });

        window.mermaidReady = true;

        window.renderMermaid = async function(diagram) {
            try {
                const container = document.getElementById('result');
                const { svg } = await mermaid.render('mermaid-diagram', diagram);
                container.innerHTML = svg;

                return {
                    success: true,
                    svgGenerated: !!container.querySelector('svg')
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message || String(error)
                };
            }
        };
    </script>
</head>
<body>
    <div id="result"></div>
</body>
</html>
        `;

        // Navigate to the HTML page
        await page.setContent(html);

        // Wait for Mermaid to be ready
        await page.waitForFunction(() => window.mermaidReady === true, { timeout: 10000 });

        // Render the Mermaid diagram
        const renderResult = await page.evaluate(async (diagram: string) => {
            return await window.renderMermaid(diagram);
        }, result.mermaidDiagram);

        result.success = renderResult.success;
        result.svgGenerated = renderResult.svgGenerated;

        if (!renderResult.success) {
            result.errorMessage = renderResult.error || 'Unknown rendering error';
        }

    } catch (error: any) {
        result.errorMessage = error.message || String(error);
        result.success = false;
    }

    reporter.addResult(result);
    return result;
}

// Helper to load example files
const loadExample = (category: string, filename: string): string => {
    const examplesDir = path.join(process.cwd(), 'examples');
    const filePath = path.join(examplesDir, category, filename);
    return fs.readFileSync(filePath, 'utf-8');
};

// Test suite
test.describe('E2E Mermaid Rendering Tests', () => {
    test('Basic: Minimal Machine', async ({ page }) => {
        const source = loadExample('basic', 'minimal.dygram');
        const result = await testMermaidRendering(page, 'Minimal Machine', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: Empty and Minimal', async ({ page }) => {
        const source = loadExample('basic', 'empty-and-minimal.dygram');
        const result = await testMermaidRendering(page, 'Empty and Minimal', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: Simple Nodes (3)', async ({ page }) => {
        const source = loadExample('basic', 'simple-nodes-3.dygram');
        const result = await testMermaidRendering(page, 'Simple Nodes (3)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: Typed Nodes', async ({ page }) => {
        const source = loadExample('basic', 'typed-nodes.dygram');
        const result = await testMermaidRendering(page, 'Typed Nodes', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Basic: All Node Types', async ({ page }) => {
        const source = loadExample('basic', 'all-node-types.dygram');
        const result = await testMermaidRendering(page, 'All Node Types', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Attributes: Basic Attributes', async ({ page }) => {
        const source = loadExample('attributes', 'basic-attributes.dygram');
        const result = await testMermaidRendering(page, 'Basic Attributes', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Attributes: Deep Attributes', async ({ page }) => {
        const source = loadExample('attributes', 'deep-attributes.dygram');
        const result = await testMermaidRendering(page, 'Deep Attributes', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Basic Edges', async ({ page }) => {
        const source = loadExample('edges', 'basic-edges.dygram');
        const result = await testMermaidRendering(page, 'Basic Edges', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Labeled Edges', async ({ page }) => {
        const source = loadExample('edges', 'labeled-edges.dygram');
        const result = await testMermaidRendering(page, 'Labeled Edges', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Mixed Arrow Types', async ({ page }) => {
        const source = loadExample('edges', 'mixed-arrow-types.dygram');
        const result = await testMermaidRendering(page, 'Mixed Arrow Types', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edges: Quoted Labels', async ({ page }) => {
        const source = loadExample('edges', 'quoted-labels.dygram');
        const result = await testMermaidRendering(page, 'Quoted Labels', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Nested (2 levels)', async ({ page }) => {
        const source = loadExample('nesting', 'nested-2-levels.dygram');
        const result = await testMermaidRendering(page, 'Nested (2 levels)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Nested (3 levels)', async ({ page }) => {
        const source = loadExample('nesting', 'nested-3-levels.dygram');
        const result = await testMermaidRendering(page, 'Nested (3 levels)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Complex Nesting', async ({ page }) => {
        const source = loadExample('nesting', 'complex-nesting.dygram');
        const result = await testMermaidRendering(page, 'Complex Nesting', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Deep Nested (5 levels)', async ({ page }) => {
        const source = loadExample('nesting', 'deep-nested-5-levels.dygram');
        const result = await testMermaidRendering(page, 'Deep Nested (5 levels)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Complex: Complex Machine', async ({ page }) => {
        const source = loadExample('complex', 'complex-machine.dygram');
        const result = await testMermaidRendering(page, 'Complex Machine', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Complex: Unicode Machine', async ({ page }) => {
        const source = loadExample('complex', 'unicode-machine.dygram');
        const result = await testMermaidRendering(page, 'Unicode Machine', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Complex: Context Heavy', async ({ page }) => {
        const source = loadExample('complex', 'context-heavy.dygram');
        const result = await testMermaidRendering(page, 'Context Heavy', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Stress: Large Machine (50 nodes)', async ({ page }) => {
        const source = loadExample('stress', 'large-50-nodes.dygram');
        const result = await testMermaidRendering(page, 'Large Machine (50 nodes)', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edge Cases: Special Characters', async ({ page }) => {
        const source = loadExample('edge-cases', 'special-characters.dygram');
        const result = await testMermaidRendering(page, 'Special Characters', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Edge Cases: Edge Cases Collection', async ({ page }) => {
        const source = loadExample('edge-cases', 'edge-cases-collection.dygram');
        const result = await testMermaidRendering(page, 'Edge Cases Collection', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: User Onboarding', async ({ page }) => {
        const source = loadExample('workflows', 'user-onboarding.dygram');
        const result = await testMermaidRendering(page, 'User Onboarding', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: Order Processing', async ({ page }) => {
        const source = loadExample('workflows', 'order-processing.dygram');
        const result = await testMermaidRendering(page, 'Order Processing', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: CI/CD Pipeline', async ({ page }) => {
        const source = loadExample('workflows', 'ci-cd-pipeline.dygram');
        const result = await testMermaidRendering(page, 'CI/CD Pipeline', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: Smart Task Prioritizer', async ({ page }) => {
        const source = loadExample('workflows', 'smart-task-prioritizer.dygram');
        const result = await testMermaidRendering(page, 'Smart Task Prioritizer', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Workflows: Code Generation Demo', async ({ page }) => {
        const source = loadExample('workflows', 'code-generation-demo.dygram');
        const result = await testMermaidRendering(page, 'Code Generation Demo', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });

    test('Nesting: Semantic Nesting Example', async ({ page }) => {
        const source = loadExample('nesting', 'semantic-nesting-example.dygram');
        const result = await testMermaidRendering(page, 'Semantic Nesting Example', source);
        expect(result.success, `Rendering failed: ${result.errorMessage}`).toBe(true);
        expect(result.svgGenerated, 'SVG was not generated').toBe(true);
    });
});
