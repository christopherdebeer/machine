import { beforeAll, describe, expect, test } from "vitest";
import { EmptyFileSystem } from "langium";
import { parseHelper } from "langium/test";
import { createMachineServices } from "../../src/language/machine-module.js";
import { Machine, isMachine } from "../../src/language/generated/ast.js";
import { generateJSON, generateGraphviz, generateDSL } from "../../src/language/generator/generator.js";
import { renderDotToSVG } from "../../src/language/diagram/graphviz-generator.js";
import { base64UrlEncode } from "../../src/utils/url-encoding.js";
import * as fs from "node:fs";
import * as path from "node:path";
import * as crypto from "node:crypto";

// Import the examples list generated by prebuild
import examplesList from "../../src/generated/examples-list.json" assert { type: "json" };

let services: ReturnType<typeof createMachineServices>;
let parse: ReturnType<typeof parseHelper<Machine>>;

beforeAll(async () => {
    services = createMachineServices(EmptyFileSystem);
    parse = parseHelper<Machine>(services.Machine);
});

/**
 * Comprehensive Generative Integration Test Suite
 *
 * This test suite programmatically iterates over ALL extracted examples
 * from the build process and validates:
 * 1. Parsing (no lexer/parser errors)
 * 2. JSON generation (completeness)
 * 3. Graphviz DOT generation (losslessness)
 * 4. SVG rendering (renderability)
 *
 * Examples are loaded from src/generated/examples-list.json which is
 * generated by scripts/prebuild.js from markdown documentation.
 */

interface SnapshotDiff {
    type: 'json' | 'graphviz' | 'svg';
    expected: string;
    actual: string;
    diff?: string;  // Unified diff format
}

interface ValidationResult {
    testName: string;
    category: string;
    path: string;
    source: string;
    passed: boolean;
    parseErrors: string[];
    validationErrors: string[];  // NEW: Semantic/type validation errors
    transformErrors: string[];
    completenessIssues: string[];
    losslessnessIssues: string[];
    graphvizParseErrors: string[];
    svgRenderErrors: string[];
    dslRoundTripErrors: string[];  // NEW: DSL round-trip errors
    snapshotMismatches: string[];
    snapshotDiffs: SnapshotDiff[];  // NEW: Detailed snapshot diffs
    jsonOutput?: any;
    graphvizOutput?: string;
    svgOutput?: string;
    dslOutput?: string;  // NEW: Regenerated DSL
}

/**
 * Snapshot Manager
 *
 * Manages snapshot storage, comparison, and updates for test outputs.
 * Snapshots are stored in test/integration/__snapshots__/ and tracked in git.
 */
class SnapshotManager {
    private snapshotDir: string;
    private updateSnapshots: boolean;
    private selectiveUpdate: boolean;
    private allowedFiles: Set<string> | null;

    constructor() {
        this.snapshotDir = path.join(process.cwd(), 'test', 'integration', '__snapshots__');
        // Check for UPDATE_SNAPSHOTS environment variable
        this.updateSnapshots = process.env.UPDATE_SNAPSHOTS === 'true';

        // Check for selective update mode
        this.selectiveUpdate = process.env.SELECTIVE_SNAPSHOT_UPDATE === 'true';
        this.allowedFiles = null;

        if (this.selectiveUpdate && process.env.SNAPSHOT_UPDATE_CONFIG) {
            try {
                const configPath = process.env.SNAPSHOT_UPDATE_CONFIG;
                if (fs.existsSync(configPath)) {
                    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
                    this.allowedFiles = new Set(config.files || []);
                    console.log(`üìã Selective update mode: ${this.allowedFiles.size} file(s) allowed`);
                }
            } catch (e) {
                console.warn(`Failed to load selective update config: ${e}`);
            }
        }

        if (!fs.existsSync(this.snapshotDir)) {
            fs.mkdirSync(this.snapshotDir, { recursive: true });
        }
    }

    /**
     * Get the snapshot file path for a given test
     */
    private getSnapshotPath(testName: string, category: string): string {
        const sanitizedCategory = category.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const sanitizedName = testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        return path.join(this.snapshotDir, `${sanitizedCategory}_${sanitizedName}.json`);
    }

    /**
     * Generate a hash of content for quick comparison
     */
    private hashContent(content: string): string {
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    /**
     * Load existing snapshot for a test, if it exists
     */
    loadSnapshot(testName: string, category: string): any | null {
        const snapshotPath = this.getSnapshotPath(testName, category);
        if (!fs.existsSync(snapshotPath)) {
            return null;
        }
        try {
            const content = fs.readFileSync(snapshotPath, 'utf-8');
            return JSON.parse(content);
        } catch (e) {
            console.warn(`Failed to load snapshot for ${testName}: ${e}`);
            return null;
        }
    }

    /**
     * Save a snapshot for a test
     */
    saveSnapshot(testName: string, category: string, snapshot: any): void {
        const snapshotPath = this.getSnapshotPath(testName, category);
        fs.writeFileSync(snapshotPath, JSON.stringify(snapshot, null, 2), 'utf-8');
    }

    /**
     * Check if a snapshot file is allowed for update in selective mode
     */
    private isAllowedForUpdate(testName: string, category: string): boolean {
        if (!this.selectiveUpdate || !this.allowedFiles) {
            return true; // Not in selective mode, allow all
        }

        const sanitizedCategory = category.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const sanitizedName = testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const baseName = `${sanitizedCategory}_${sanitizedName}`;

        return this.allowedFiles.has(baseName);
    }

    /**
     * Compare current outputs against snapshot and return differences with detailed diffs
     */
    compareWithSnapshot(
        testName: string,
        category: string,
        jsonOutput: any,
        graphvizOutput: string,
        svgOutput: string
    ): { differences: string[], diffs: SnapshotDiff[] } {
        const differences: string[] = [];
        const diffs: SnapshotDiff[] = [];
        const snapshot = this.loadSnapshot(testName, category);

        // Determine if we should update this specific snapshot
        const shouldUpdate = this.updateSnapshots && this.isAllowedForUpdate(testName, category);

        if (!snapshot) {
            if (shouldUpdate) {
                // Create new snapshot
                this.saveSnapshot(testName, category, {
                    json: jsonOutput,
                    graphviz: graphvizOutput,
                    svgHash: this.hashContent(svgOutput)
                });
                differences.push('New snapshot created');
            } else {
                differences.push('No baseline snapshot found. Run tests with UPDATE_SNAPSHOTS=true to create snapshots.');
            }
            return { differences, diffs };
        }

        // Compare JSON output (excluding $sourceRange fields which can differ due to formatting)
        const currentJsonNormalized = this.removeSourceRanges(jsonOutput);
        const snapshotJsonNormalized = this.removeSourceRanges(snapshot.json);

        const currentJsonStr = JSON.stringify(currentJsonNormalized, null, 2);
        const snapshotJsonStr = JSON.stringify(snapshotJsonNormalized, null, 2);
        if (currentJsonStr !== snapshotJsonStr) {
            differences.push('JSON output differs from snapshot');
            diffs.push({
                type: 'json',
                expected: snapshotJsonStr,
                actual: currentJsonStr,
                diff: this.generateUnifiedDiff(snapshotJsonStr, currentJsonStr, 'JSON')
            });
        }

        // Compare Graphviz output
        if (graphvizOutput !== snapshot.graphviz) {
            differences.push('Graphviz DOT output differs from snapshot');
            diffs.push({
                type: 'graphviz',
                expected: snapshot.graphviz,
                actual: graphvizOutput,
                diff: this.generateUnifiedDiff(snapshot.graphviz, graphvizOutput, 'Graphviz DOT')
            });
        }

        // Compare SVG output (using hash for efficiency)
        const currentSvgHash = this.hashContent(svgOutput);
        if (currentSvgHash !== snapshot.svgHash) {
            differences.push('SVG output differs from snapshot');
            // For SVG we just note the hash difference, showing full SVG diffs would be too large
            diffs.push({
                type: 'svg',
                expected: `Hash: ${snapshot.svgHash}`,
                actual: `Hash: ${currentSvgHash}`,
                diff: `SVG output hash changed.\nExpected: ${snapshot.svgHash}\nActual: ${currentSvgHash}`
            });
        }

        // Update snapshot if requested and allowed
        if (differences.length > 0 && shouldUpdate) {
            this.saveSnapshot(testName, category, {
                json: jsonOutput,
                graphviz: graphvizOutput,
                svgHash: currentSvgHash
            });
            differences.push('Snapshot updated');
        }

        return { differences, diffs };
    }

    /**
     * Generate a simple unified diff between two strings
     */
    private generateUnifiedDiff(expected: string, actual: string, label: string): string {
        const expectedLines = expected.split('\n');
        const actualLines = actual.split('\n');

        let diff = `--- Expected ${label}\n+++ Actual ${label}\n`;
        const maxLines = Math.max(expectedLines.length, actualLines.length);

        for (let i = 0; i < maxLines; i++) {
            const expLine = expectedLines[i];
            const actLine = actualLines[i];

            if (expLine === actLine) {
                // Line unchanged (show first 50 and last 50 unchanged lines)
                if (i < 3 || i > maxLines - 4) {
                    diff += `  ${expLine || ''}\n`;
                } else if (i === 3) {
                    diff += `  ... (${maxLines - 7} unchanged lines) ...\n`;
                }
            } else {
                if (expLine !== undefined) {
                    diff += `- ${expLine}\n`;
                }
                if (actLine !== undefined) {
                    diff += `+ ${actLine}\n`;
                }
            }
        }

        return diff;
    }

    /**
     * Remove $sourceRange fields from JSON for comparison
     * $sourceRange contains line/character positions that will differ in DSL round-trips
     * due to formatting differences, but don't indicate semantic changes
     */
    private removeSourceRanges(obj: any): any {
        if (obj === null || obj === undefined) {
            return obj;
        }

        if (Array.isArray(obj)) {
            return obj.map(item => this.removeSourceRanges(item));
        }

        if (typeof obj === 'object') {
            const result: any = {};
            for (const key in obj) {
                if (key === '$sourceRange') {
                    // Skip $sourceRange fields
                    continue;
                }
                result[key] = this.removeSourceRanges(obj[key]);
            }
            return result;
        }

        return obj;
    }

    /**
     * Get all snapshot files
     */
    getAllSnapshots(): string[] {
        if (!fs.existsSync(this.snapshotDir)) {
            return [];
        }
        return fs.readdirSync(this.snapshotDir)
            .filter(file => file.endsWith('.json'))
            .map(file => path.join(this.snapshotDir, file));
    }

    /**
     * Check if snapshots should be updated
     */
    shouldUpdateSnapshots(): boolean {
        return this.updateSnapshots;
    }
}

class ValidationReporter {
    private results: ValidationResult[] = [];
    private outputDir = path.join(process.cwd(), 'test-output', 'comprehensive-generative');
    // Playground base URL - can be configured via environment variable
    private playgroundUrl = (process.env.VITE_BASE_URL || '/machine/') + 'playground-mobile.html';

    constructor() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    /**
     * Generate a playground link with source code pre-loaded
     */
    private generatePlaygroundLink(source: string): string {
        // Encode the source code using the shared URL encoding utility
        const encoded = base64UrlEncode(source);
        return `${this.playgroundUrl}#content=${encoded}`;
    }

    addResult(result: ValidationResult): void {
        this.results.push(result);

        // Write individual outputs for manual inspection
        const fileName = result.testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const categoryDir = path.join(this.outputDir, result.category);

        if (!fs.existsSync(categoryDir)) {
            fs.mkdirSync(categoryDir, { recursive: true });
        }

        // Write markdown report
        let mdContent = `# ${result.testName}\n\n`;
        mdContent += `**Category**: ${result.category}\n`;
        mdContent += `**Path**: ${result.path}\n`;
        mdContent += `**Status**: ${result.passed ? '‚úÖ PASSED' : '‚ùå FAILED'}\n\n`;

        // Add playground link
        const playgroundLink = this.generatePlaygroundLink(result.source);
        mdContent += `[üéÆ Open in Playground](${playgroundLink})\n\n`;

        mdContent += `## Source\n\`\`\`dygram\n${result.source}\n\`\`\`\n\n`;

        if (result.jsonOutput) {
            mdContent += `## JSON Output\n\`\`\`json\n${JSON.stringify(result.jsonOutput, null, 2)}\n\`\`\`\n\n`;
        }

        if (result.graphvizOutput) {
            mdContent += `## Graphviz DOT Output\n\`\`\`dot\n${result.graphvizOutput}\n\`\`\`\n\n`;
        }

        if (result.dslOutput) {
            mdContent += `## Regenerated DSL (Round-trip)\n\`\`\`dygram\n${result.dslOutput}\n\`\`\`\n\n`;
        }

        mdContent += `## Validation Results\n`;
        mdContent += `- Parse Errors: ${result.parseErrors.length}\n`;
        mdContent += `- Validation Errors: ${result.validationErrors.length}\n`;
        mdContent += `- Transform Errors: ${result.transformErrors.length}\n`;
        mdContent += `- Completeness Issues: ${result.completenessIssues.length}\n`;
        mdContent += `- Losslessness Issues: ${result.losslessnessIssues.length}\n`;
        mdContent += `- Graphviz Parse Errors: ${result.graphvizParseErrors.length}\n`;
        mdContent += `- SVG Render Errors: ${result.svgRenderErrors.length}\n`;
        mdContent += `- DSL Round-trip Errors: ${result.dslRoundTripErrors.length}\n`;
        mdContent += `- Snapshot Mismatches: ${result.snapshotMismatches.length}\n\n`;

        if (result.parseErrors.length > 0) {
            mdContent += `### Parse Errors\n${result.parseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.validationErrors.length > 0) {
            mdContent += `### Validation Errors\n${result.validationErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.transformErrors.length > 0) {
            mdContent += `### Transform Errors\n${result.transformErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.completenessIssues.length > 0) {
            mdContent += `### Completeness Issues\n${result.completenessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.losslessnessIssues.length > 0) {
            mdContent += `### Losslessness Issues\n${result.losslessnessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.graphvizParseErrors.length > 0) {
            mdContent += `### Graphviz Parse Errors\n${result.graphvizParseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.svgRenderErrors.length > 0) {
            mdContent += `### SVG Render Errors\n${result.svgRenderErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.dslRoundTripErrors.length > 0) {
            mdContent += `### DSL Round-trip Errors\n${result.dslRoundTripErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.snapshotMismatches.length > 0) {
            mdContent += `### Snapshot Mismatches\n${result.snapshotMismatches.map(e => `- ${e}`).join('\n')}\n\n`;
        }

        if (result.snapshotDiffs.length > 0) {
            mdContent += `### Snapshot Diffs\n\n`;
            result.snapshotDiffs.forEach((diff) => {
                mdContent += `#### ${diff.type.toUpperCase()} Diff\n\n`;
                mdContent += `\`\`\`diff\n${diff.diff}\n\`\`\`\n\n`;
                mdContent += `<details>\n<summary>Show Full Comparison</summary>\n\n`;
                mdContent += `**Expected (Snapshot):**\n\`\`\`${diff.type === 'json' ? 'json' : diff.type === 'graphviz' ? 'dot' : 'text'}\n${diff.expected}\n\`\`\`\n\n`;
                mdContent += `**Actual (Current):**\n\`\`\`${diff.type === 'json' ? 'json' : diff.type === 'graphviz' ? 'dot' : 'text'}\n${diff.actual}\n\`\`\`\n\n`;
                mdContent += `</details>\n\n`;
            });
        }

        fs.writeFileSync(path.join(categoryDir, `${fileName}.md`), mdContent);

        // Write SVG if it was successfully generated
        if (result.svgOutput && result.svgRenderErrors.length === 0) {
            fs.writeFileSync(path.join(categoryDir, `${fileName}.svg`), result.svgOutput);
        }

        // Write regenerated DSL if it was successfully generated
        if (result.dslOutput && result.dslRoundTripErrors.length === 0) {
            fs.writeFileSync(path.join(categoryDir, `${fileName}.roundtrip.dy`), result.dslOutput);
        }
    }

    generateReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.passed).length;
        const failed = total - passed;

        let report = `# Comprehensive Generative Test Report\n\n`;
        report += `Generated: ${new Date().toISOString()}\n\n`;
        report += `## Summary\n`;
        report += `- Total Tests: ${total}\n`;
        report += `- Passed: ${passed}\n`;
        report += `- Failed: ${failed}\n`;
        report += `- Success Rate: ${((passed / total) * 100).toFixed(2)}%\n\n`;

        // Group by category
        const byCategory: Record<string, { total: number; passed: number }> = {};
        this.results.forEach(r => {
            if (!byCategory[r.category]) {
                byCategory[r.category] = { total: 0, passed: 0 };
            }
            byCategory[r.category].total++;
            if (r.passed) byCategory[r.category].passed++;
        });

        report += `## Results by Category\n`;
        Object.keys(byCategory).sort().forEach(category => {
            const { total, passed } = byCategory[category];
            const rate = ((passed / total) * 100).toFixed(1);
            report += `- **${category}**: ${passed}/${total} (${rate}%)\n`;
        });
        report += `\n`;

        // Group issues by type
        const allParseErrors = this.results.flatMap(r => r.parseErrors);
        const allValidationErrors = this.results.flatMap(r => r.validationErrors);
        const allTransformErrors = this.results.flatMap(r => r.transformErrors);
        const allCompletenessIssues = this.results.flatMap(r => r.completenessIssues);
        const allLosslessnessIssues = this.results.flatMap(r => r.losslessnessIssues);
        const allGraphvizParseErrors = this.results.flatMap(r => r.graphvizParseErrors);
        const allSvgRenderErrors = this.results.flatMap(r => r.svgRenderErrors);
        const allDslRoundTripErrors = this.results.flatMap(r => r.dslRoundTripErrors);
        const allSnapshotMismatches = this.results.flatMap(r => r.snapshotMismatches);

        report += `## Issue Summary\n`;
        report += `- Parse Errors: ${allParseErrors.length}\n`;
        report += `- Validation Errors: ${allValidationErrors.length}\n`;
        report += `- Transform Errors: ${allTransformErrors.length}\n`;
        report += `- Completeness Issues: ${allCompletenessIssues.length}\n`;
        report += `- Losslessness Issues: ${allLosslessnessIssues.length}\n`;
        report += `- Graphviz Parse Errors: ${allGraphvizParseErrors.length}\n`;
        report += `- SVG Render Errors: ${allSvgRenderErrors.length}\n`;
        report += `- DSL Round-trip Errors: ${allDslRoundTripErrors.length}\n`;
        report += `- Snapshot Mismatches: ${allSnapshotMismatches.length}\n\n`;

        // Failed tests details
        const failedResults = this.results.filter(r => !r.passed);
        if (failedResults.length > 0) {
            report += `## Failed Tests (${failedResults.length})\n\n`;
            failedResults.forEach(r => {
                report += `### ${r.testName} (${r.category})\n`;
                report += `Path: ${r.path}\n\n`;
                if (r.parseErrors.length > 0) {
                    report += `**Parse Errors:**\n${r.parseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.validationErrors.length > 0) {
                    report += `**Validation Errors:**\n${r.validationErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.transformErrors.length > 0) {
                    report += `**Transform Errors:**\n${r.transformErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.completenessIssues.length > 0) {
                    report += `**Completeness Issues:**\n${r.completenessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.losslessnessIssues.length > 0) {
                    report += `**Losslessness Issues:**\n${r.losslessnessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.graphvizParseErrors.length > 0) {
                    report += `**Graphviz Parse Errors:**\n${r.graphvizParseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.svgRenderErrors.length > 0) {
                    report += `**SVG Render Errors:**\n${r.svgRenderErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.dslRoundTripErrors.length > 0) {
                    report += `**DSL Round-trip Errors:**\n${r.dslRoundTripErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.snapshotMismatches.length > 0) {
                    report += `**Snapshot Mismatches:**\n${r.snapshotMismatches.map(e => `- ${e}`).join('\n')}\n\n`;
                }
            });
        }

        return report;
    }

    generateHtmlReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.passed).length;
        const failed = total - passed;
        const successRate = ((passed / total) * 100).toFixed(2);

        const allParseErrors = this.results.flatMap(r => r.parseErrors);
        const allValidationErrors = this.results.flatMap(r => r.validationErrors);
        const allTransformErrors = this.results.flatMap(r => r.transformErrors);
        const allCompletenessIssues = this.results.flatMap(r => r.completenessIssues);
        const allLosslessnessIssues = this.results.flatMap(r => r.losslessnessIssues);
        const allGraphvizParseErrors = this.results.flatMap(r => r.graphvizParseErrors);
        const allSvgRenderErrors = this.results.flatMap(r => r.svgRenderErrors);
        const allDslRoundTripErrors = this.results.flatMap(r => r.dslRoundTripErrors);
        const allSnapshotMismatches = this.results.flatMap(r => r.snapshotMismatches);

        // Group by category
        const byCategory: Record<string, { total: number; passed: number }> = {};
        this.results.forEach(r => {
            if (!byCategory[r.category]) {
                byCategory[r.category] = { total: 0, passed: 0 };
            }
            byCategory[r.category].total++;
            if (r.passed) byCategory[r.category].passed++;
        });

        // Get all unique categories for filter dropdown
        const allCategories = Object.keys(byCategory).sort();

        let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Generative Test Report - DyGram</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Space Mono', monospace, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #0F0F0F; background: #F7F7F7; padding: 1rem; }
        .container { max-width: 1600px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 1.5rem; }
        h1 { color: #0F0F0F; margin-bottom: 0.25rem; font-size: 1.75rem; font-weight: 700; }
        .subtitle { color: #303030; margin-bottom: 1.5rem; font-size: 0.875rem; }

        /* Filters */
        .filters { background: #F7F7F7; padding: 1rem; border-radius: 6px; margin-bottom: 1.5rem; border-left: 8px solid #FF5E5B; }
        .filters h2 { font-size: 1rem; margin-bottom: 0.75rem; color: #0F0F0F; }
        .filter-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
        .filter-group { display: flex; flex-direction: column; gap: 0.25rem; }
        .filter-group label { font-size: 0.75rem; font-weight: 600; color: #303030; text-transform: uppercase; letter-spacing: 0.5px; }
        .filter-group select { padding: 0.5rem; border: 2px solid #0F0F0F; background: white; color: #0F0F0F; font-family: 'Space Mono', monospace; font-size: 0.875rem; border-radius: 4px; cursor: pointer; }
        .filter-group select:focus { outline: none; border-color: #FF5E5B; }
        .filter-reset { padding: 0.5rem 1rem; background: #0F0F0F; color: white; border: none; cursor: pointer; font-family: 'Space Mono', monospace; font-weight: 600; font-size: 0.875rem; border-radius: 4px; margin-top: 1.25rem; }
        .filter-reset:hover { background: #FF5E5B; }

        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem; }
        .stat-card { padding: 1rem; border-radius: 6px; text-align: center; border-left: 4px solid #0F0F0F; }
        .stat-card.total { background: #F7F7F7; }
        .stat-card.passed { background: #e8f5e9; border-left-color: #4caf50; }
        .stat-card.failed { background: #ffebee; border-left-color: #FF5E5B; }
        .stat-value { font-size: 2rem; font-weight: bold; color: #0F0F0F; }
        .stat-label { color: #303030; font-size: 0.75rem; margin-top: 0.25rem; text-transform: uppercase; letter-spacing: 0.5px; }
        .issues { margin-bottom: 1.5rem; }
        .issues h2 { font-size: 1.25rem; margin-bottom: 0.75rem; color: #0F0F0F; }
        .issue-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; }
        .issue-card { padding: 0.75rem; border-radius: 4px; background: #F7F7F7; border-left: 4px solid #0F0F0F; cursor: pointer; transition: all 0.2s; }
        .issue-card:hover { background: #FF5E5B; color: white; transform: translateY(-2px); }
        .issue-card:hover .issue-count, .issue-card:hover .issue-label { color: white; }
        .issue-card.active { background: #FF5E5B; color: white; }
        .issue-card.active .issue-count, .issue-card.active .issue-label { color: white; }
        .issue-count { font-size: 1.25rem; font-weight: bold; color: #0F0F0F; }
        .issue-label { font-size: 0.75rem; color: #303030; text-transform: uppercase; letter-spacing: 0.5px; }
        .category-section { margin-bottom: 1.5rem; }
        .category-section.hidden { display: none; }
        .category-header { background: #F7F7F7; padding: 0.75rem; border-radius: 4px; cursor: pointer; user-select: none; border-left: 4px solid #0F0F0F; }
        .category-header:hover { background: #303030; color: white; }
        .category-header:hover h3, .category-header:hover .category-stats { color: white; }
        .category-header h3 { display: flex; align-items: center; gap: 0.5rem; font-size: 1.1rem; color: #0F0F0F; }
        .category-toggle { display: inline-block; transition: transform 0.2s; }
        .category-toggle.collapsed { transform: rotate(-90deg); }
        .category-stats { display: flex; gap: 0.75rem; align-items: center; margin-top: 0.5rem; font-size: 0.875rem; color: #303030; }
        .category-bar { flex: 1; height: 16px; background: #e0e0e0; border-radius: 8px; overflow: hidden; }
        .category-bar-fill { height: 100%; background: #FF5E5B; transition: width 0.3s; }
        .test-list { margin-top: 0.75rem; display: none; }
        .test-list.expanded { display: block; }
        .test-item { border: 2px solid #0F0F0F; border-radius: 4px; margin-bottom: 0.75rem; overflow: hidden; }
        .test-item.hidden { display: none; }
        .test-header { padding: 0.75rem; background: #F7F7F7; display: flex; justify-content: space-between; align-items: center; cursor: pointer; gap: 0.5rem; flex-wrap: wrap; }
        .test-header:hover { background: #303030; color: white; }
        .test-name { font-weight: 600; font-size: 0.9rem; word-break: break-word; }
        .test-status { padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.5px; }
        .test-status.passed { background: #4caf50; color: white; }
        .test-status.failed { background: #FF5E5B; color: white; }
        .test-status.snapshot-mismatch { background: #ff9800; color: white; }
        .test-details { padding: 1rem; display: none; background: white; border-top: 2px solid #0F0F0F; }
        .test-details.active { display: block; }
        .tabs { display: flex; gap: 0.25rem; margin-bottom: 0.75rem; border-bottom: 2px solid #0F0F0F; flex-wrap: wrap; }
        .tab { padding: 0.5rem 0.75rem; cursor: pointer; background: none; border: none; font-size: 0.8rem; font-weight: 600; color: #303030; border-bottom: 2px solid transparent; margin-bottom: -2px; font-family: 'Space Mono', monospace; text-transform: uppercase; letter-spacing: 0.5px; }
        .tab:hover { color: #FF5E5B; }
        .tab.active { color: #FF5E5B; border-bottom-color: #FF5E5B; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-content h4 { font-size: 1rem; margin-bottom: 0.5rem; color: #0F0F0F; }
        .code-block { background: #1A1A1A; color: #F7F7F7; border-left: 8px solid #FF5E5B; padding: 0.75rem; overflow-x: auto; font-family: 'Courier New', 'Fira Code', monospace; font-size: 0.8rem; margin: 0.5rem 0; white-space: pre-wrap; word-break: break-word; border-radius: 4px; }
        .error-section { margin-top: 0.75rem; }
        .error-section h4 { color: #FF5E5B; margin-bottom: 0.5rem; font-size: 0.95rem; }
        .warning-section h4 { color: #ff9800; margin-bottom: 0.5rem; font-size: 0.95rem; }
        .error-list { list-style: none; padding-left: 0.75rem; }
        .error-list li { padding: 0.25rem 0; color: #303030; font-size: 0.85rem; }
        .error-list li:before { content: "‚ö† "; color: #FF5E5B; }
        .warning-list li:before { content: "‚ö† "; color: #ff9800; }
        .svg-container { border: 2px solid #0F0F0F; border-radius: 4px; padding: 0.75rem; background: white; margin: 0.5rem 0; overflow-x: auto; }
        .svg-container svg { max-width: 100%; height: auto; }
        .snapshot-badge { display: inline-block; padding: 0.25rem 0.5rem; background: #ff9800; color: white; font-size: 0.7rem; border-radius: 4px; margin-left: 0.5rem; }
        a { color: #FF5E5B; text-decoration: none; font-weight: 600; }
        a:hover { text-decoration: underline; }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 0.5rem; }
            .container { padding: 1rem; border-radius: 4px; }
            h1 { font-size: 1.5rem; }
            .subtitle { font-size: 0.8rem; }
            .filter-controls { grid-template-columns: 1fr; }
            .summary { grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
            .stat-card { padding: 0.75rem; }
            .stat-value { font-size: 1.5rem; }
            .stat-label { font-size: 0.7rem; }
            .issue-grid { grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
            .issue-card { padding: 0.5rem; }
            .issue-count { font-size: 1.1rem; }
            .issue-label { font-size: 0.7rem; }
            .category-header { padding: 0.5rem; }
            .category-header h3 { font-size: 1rem; }
            .category-stats { font-size: 0.8rem; gap: 0.5rem; }
            .test-header { padding: 0.5rem; }
            .test-name { font-size: 0.85rem; }
            .test-status { font-size: 0.7rem; padding: 0.2rem 0.4rem; }
            .test-details { padding: 0.75rem; }
            .tabs { gap: 0.15rem; }
            .tab { padding: 0.4rem 0.5rem; font-size: 0.75rem; }
            .code-block { padding: 0.5rem; font-size: 0.75rem; }
            .snapshot-badge { font-size: 0.65rem; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.25rem; }
            .summary { grid-template-columns: 1fr; }
            .issue-grid { grid-template-columns: 1fr; }
            .category-bar { height: 12px; }
            .test-name { font-size: 0.8rem; }
        }
    </style>
    <script>
        // Store all test data for filtering
        const testData = [];

        function toggleCategory(categoryId) {
            const testList = document.getElementById(categoryId);
            const toggle = document.getElementById(categoryId + '-toggle');
            testList.classList.toggle('expanded');
            toggle.classList.toggle('collapsed');
        }
        function toggleDetails(id) {
            const details = document.getElementById(id);
            details.classList.toggle('active');
        }
        function showTab(testId, tabName) {
            const tabs = document.querySelectorAll(\`#\${testId} .tab\`);
            const contents = document.querySelectorAll(\`#\${testId} .tab-content\`);
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            document.querySelector(\`#\${testId} .tab[data-tab="\${tabName}"]\`).classList.add('active');
            document.getElementById(\`\${testId}-\${tabName}\`).classList.add('active');
        }

        function filterTests() {
            const statusFilter = document.getElementById('statusFilter').value;
            const categoryFilter = document.getElementById('categoryFilter').value;
            const issueFilter = document.getElementById('issueFilter').value;

            // Filter categories
            document.querySelectorAll('.category-section').forEach(section => {
                const category = section.dataset.category;
                const categoryMatch = categoryFilter === 'all' || category === categoryFilter;

                if (!categoryMatch) {
                    section.classList.add('hidden');
                    return;
                }

                // Filter tests within category
                let visibleCount = 0;
                section.querySelectorAll('.test-item').forEach(item => {
                    const testId = item.dataset.testId;
                    const test = testData.find(t => t.id === testId);

                    if (!test) {
                        item.classList.add('hidden');
                        return;
                    }

                    const statusMatch = statusFilter === 'all' ||
                        (statusFilter === 'passed' && test.passed) ||
                        (statusFilter === 'failed' && !test.passed);

                    const issueMatch = issueFilter === 'all' || test.issues.includes(issueFilter);

                    if (statusMatch && issueMatch) {
                        item.classList.remove('hidden');
                        visibleCount++;
                    } else {
                        item.classList.add('hidden');
                    }
                });

                // Hide category if no visible tests
                if (visibleCount === 0) {
                    section.classList.add('hidden');
                } else {
                    section.classList.remove('hidden');
                }
            });
        }

        function resetFilters() {
            document.getElementById('statusFilter').value = 'all';
            document.getElementById('categoryFilter').value = 'all';
            document.getElementById('issueFilter').value = 'all';
            filterTests();
        }

        function highlightIssueCard(issueType) {
            // Remove active class from all cards
            document.querySelectorAll('.issue-card').forEach(card => {
                card.classList.remove('active');
            });

            // Set filter and add active class
            if (issueType) {
                document.getElementById('issueFilter').value = issueType;
                const card = document.querySelector(\`.issue-card[data-issue="\${issueType}"]\`);
                if (card) card.classList.add('active');
            } else {
                document.getElementById('issueFilter').value = 'all';
            }

            filterTests();
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>üìä Comprehensive Generative Test Report</h1>
        <p class="subtitle">Complete DyGram transformation pipeline validation with snapshot testing</p>

        <div class="filters">
            <h2>üîç Filter Tests</h2>
            <div class="filter-controls">
                <div class="filter-group">
                    <label for="statusFilter">Status</label>
                    <select id="statusFilter" onchange="filterTests()">
                        <option value="all">All Tests</option>
                        <option value="passed">Passed Only</option>
                        <option value="failed">Failed Only</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="categoryFilter">Category</label>
                    <select id="categoryFilter" onchange="filterTests()">
                        <option value="all">All Categories</option>
                        ${allCategories.map(cat => `<option value="${this.escapeHtml(cat)}">${this.escapeHtml(cat)}</option>`).join('')}
                    </select>
                </div>
                <div class="filter-group">
                    <label for="issueFilter">Issue Type</label>
                    <select id="issueFilter" onchange="filterTests()">
                        <option value="all">All Issues</option>
                        <option value="parseErrors">Parse Errors</option>
                        <option value="validationErrors">Validation Errors</option>
                        <option value="transformErrors">Transform Errors</option>
                        <option value="completenessIssues">Completeness Issues</option>
                        <option value="losslessnessIssues">Losslessness Issues</option>
                        <option value="graphvizParseErrors">Graphviz Errors</option>
                        <option value="svgRenderErrors">SVG Errors</option>
                        <option value="dslRoundTripErrors">DSL Round-trip Errors</option>
                        <option value="snapshotMismatches">Snapshot Mismatches</option>
                    </select>
                </div>
                <div class="filter-group">
                    <button class="filter-reset" onclick="resetFilters()">Reset Filters</button>
                </div>
            </div>
        </div>

        <div class="summary">
            <div class="stat-card total">
                <div class="stat-value">${total}</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card passed">
                <div class="stat-value">${passed}</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card failed">
                <div class="stat-value">${failed}</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card total">
                <div class="stat-value">${successRate}%</div>
                <div class="stat-label">Success Rate</div>
            </div>
        </div>

        <div class="issues">
            <h2>Issue Summary</h2>
            <p style="font-size: 0.875rem; color: #303030; margin-bottom: 0.75rem;">Click on any issue type to filter tests</p>
            <div class="issue-grid">
                <div class="issue-card" data-issue="parseErrors" onclick="highlightIssueCard('parseErrors')">
                    <div class="issue-count">${allParseErrors.length}</div>
                    <div class="issue-label">Parse Errors</div>
                </div>
                <div class="issue-card" data-issue="validationErrors" onclick="highlightIssueCard('validationErrors')">
                    <div class="issue-count">${allValidationErrors.length}</div>
                    <div class="issue-label">Validation Errors</div>
                </div>
                <div class="issue-card" data-issue="transformErrors" onclick="highlightIssueCard('transformErrors')">
                    <div class="issue-count">${allTransformErrors.length}</div>
                    <div class="issue-label">Transform Errors</div>
                </div>
                <div class="issue-card" data-issue="completenessIssues" onclick="highlightIssueCard('completenessIssues')">
                    <div class="issue-count">${allCompletenessIssues.length}</div>
                    <div class="issue-label">Completeness Issues</div>
                </div>
                <div class="issue-card" data-issue="losslessnessIssues" onclick="highlightIssueCard('losslessnessIssues')">
                    <div class="issue-count">${allLosslessnessIssues.length}</div>
                    <div class="issue-label">Losslessness Issues</div>
                </div>
                <div class="issue-card" data-issue="graphvizParseErrors" onclick="highlightIssueCard('graphvizParseErrors')">
                    <div class="issue-count">${allGraphvizParseErrors.length}</div>
                    <div class="issue-label">Graphviz Errors</div>
                </div>
                <div class="issue-card" data-issue="svgRenderErrors" onclick="highlightIssueCard('svgRenderErrors')">
                    <div class="issue-count">${allSvgRenderErrors.length}</div>
                    <div class="issue-label">SVG Errors</div>
                </div>
                <div class="issue-card" data-issue="dslRoundTripErrors" onclick="highlightIssueCard('dslRoundTripErrors')">
                    <div class="issue-count">${allDslRoundTripErrors.length}</div>
                    <div class="issue-label">DSL Round-trip Errors</div>
                </div>
                <div class="issue-card" data-issue="snapshotMismatches" onclick="highlightIssueCard('snapshotMismatches')">
                    <div class="issue-count">${allSnapshotMismatches.length}</div>
                    <div class="issue-label">Snapshot Mismatches</div>
                </div>
            </div>
        </div>

        <h2>Results by Category</h2>`;

        // Category sections
        Object.keys(byCategory).sort().forEach((category, categoryIndex) => {
            const { total: catTotal, passed: catPassed } = byCategory[category];
            const rate = ((catPassed / catTotal) * 100).toFixed(1);
            const categoryResults = this.results.filter(r => r.category === category);
            const categoryId = `category-${categoryIndex}`;

            html += `
        <div class="category-section" data-category="${this.escapeHtml(category)}">
            <div class="category-header" onclick="toggleCategory('${categoryId}')">
                <h3><span class="category-toggle collapsed" id="${categoryId}-toggle">‚ñº</span> ${category}</h3>
                <div class="category-stats">
                    <span>${catPassed}/${catTotal} passed (${rate}%)</span>
                    <div class="category-bar">
                        <div class="category-bar-fill" style="width: ${rate}%"></div>
                    </div>
                </div>
            </div>
            <div class="test-list" id="${categoryId}">`;

            categoryResults.forEach((result, index) => {
                const fileName = result.testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const detailsId = `details-${category}-${index}`;
                const testId = `test-${categoryIndex}-${index}`;
                const hasSnapshotMismatch = result.snapshotMismatches.length > 0;
                const statusClass = !result.passed ? 'failed' : hasSnapshotMismatch ? 'snapshot-mismatch' : 'passed';
                const statusText = !result.passed ? 'FAILED' : hasSnapshotMismatch ? 'PASSED' : 'PASSED';

                // Build list of issue types for this test
                const issueTypes: string[] = [];
                if (result.parseErrors.length > 0) issueTypes.push('parseErrors');
                if (result.validationErrors.length > 0) issueTypes.push('validationErrors');
                if (result.transformErrors.length > 0) issueTypes.push('transformErrors');
                if (result.completenessIssues.length > 0) issueTypes.push('completenessIssues');
                if (result.losslessnessIssues.length > 0) issueTypes.push('losslessnessIssues');
                if (result.graphvizParseErrors.length > 0) issueTypes.push('graphvizParseErrors');
                if (result.svgRenderErrors.length > 0) issueTypes.push('svgRenderErrors');
                if (result.dslRoundTripErrors.length > 0) issueTypes.push('dslRoundTripErrors');
                if (result.snapshotMismatches.length > 0) issueTypes.push('snapshotMismatches');

                // Add test data for JavaScript filtering
                html += `
                <script>
                    testData.push({
                        id: '${testId}',
                        passed: ${result.passed},
                        issues: ${JSON.stringify(issueTypes)}
                    });
                </script>`;

                const playgroundLink = this.generatePlaygroundLink(result.source);
                html += `
                <div class="test-item" data-test-id="${testId}">
                    <div class="test-header" onclick="toggleDetails('${detailsId}')">
                        <span class="test-name">${result.testName}${hasSnapshotMismatch && result.passed ? '<span class="snapshot-badge">SNAPSHOT INFO</span>' : ''}</span>
                        <span class="test-status ${statusClass}">${statusText}</span>
                    </div>
                    <div class="test-details" id="${detailsId}">
                        <div class="tabs">
                            <button class="tab active" data-tab="source" onclick="showTab('${detailsId}', 'source')">Source</button>
                            <button class="tab" data-tab="json" onclick="showTab('${detailsId}', 'json')">JSON</button>
                            <button class="tab" data-tab="dot" onclick="showTab('${detailsId}', 'dot')">Graphviz DOT</button>
                            <button class="tab" data-tab="svg" onclick="showTab('${detailsId}', 'svg')">SVG</button>
                            <button class="tab" data-tab="dsl" onclick="showTab('${detailsId}', 'dsl')">DSL Round-trip</button>
                            ${result.snapshotDiffs.length > 0 ? '<button class="tab" data-tab="snapshot-diffs" onclick="showTab(\'' + detailsId + '\', \'snapshot-diffs\')">Snapshot Diffs ‚ö†Ô∏è</button>' : ''}
                            ${!result.passed || hasSnapshotMismatch ? '<button class="tab" data-tab="issues" onclick="showTab(\'' + detailsId + '\', \'issues\')">Issues</button>' : ''}
                        </div>

                        <div class="tab-content active" id="${detailsId}-source">
                            <h4>Source Code</h4>
                            <p style="margin-bottom: 0.5rem;"><a href="${playgroundLink}" target="_blank" style="color: #667eea; text-decoration: none;">üéÆ Open in Playground ‚Üí</a></p>
                            <div class="code-block">${this.escapeHtml(result.source)}</div>
                        </div>

                        <div class="tab-content" id="${detailsId}-json">
                            <h4>JSON Output</h4>
                            ${result.jsonOutput ? `<div class="code-block">${this.escapeHtml(JSON.stringify(result.jsonOutput, null, 2))}</div>` : '<p>No JSON output available</p>'}
                        </div>

                        <div class="tab-content" id="${detailsId}-dot">
                            <h4>Graphviz DOT Output</h4>
                            ${result.graphvizOutput ? `<div class="code-block">${this.escapeHtml(result.graphvizOutput)}</div>` : '<p>No DOT output available</p>'}
                        </div>

                        <div class="tab-content" id="${detailsId}-svg">
                            <h4>SVG Rendering</h4>
                            ${result.svgOutput ? `<div class="svg-container">${result.svgOutput}</div>` : '<p>No SVG output available</p>'}
                        </div>

                        <div class="tab-content" id="${detailsId}-dsl">
                            <h4>Regenerated DSL (JSON ‚Üí DSL)</h4>
                            ${result.dslOutput ? `<div class="code-block">${this.escapeHtml(result.dslOutput)}</div>` : '<p>No DSL output available</p>'}
                        </div>`;

                // Add Snapshot Diffs tab if there are any diffs
                if (result.snapshotDiffs.length > 0) {
                    html += `
                        <div class="tab-content" id="${detailsId}-snapshot-diffs">
                            <h4>Snapshot Differences</h4>
                            <p style="color: #666; margin-bottom: 1rem;">The following outputs differ from their baseline snapshots:</p>`;

                    result.snapshotDiffs.forEach((diff, idx) => {
                        html += `
                            <div class="diff-section" style="margin-bottom: 2rem; border: 1px solid #e0e0e0; border-radius: 4px; overflow: hidden;">
                                <div style="background: #f5f5f5; padding: 0.5rem 1rem; border-bottom: 1px solid #e0e0e0; font-weight: 500;">
                                    ${diff.type.toUpperCase()} Output Diff
                                </div>
                                <div style="padding: 1rem;">
                                    <div style="margin-bottom: 1rem;">
                                        <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 0.5rem; margin-bottom: 0.5rem;">
                                            <strong>Unified Diff:</strong>
                                            <pre style="margin: 0.5rem 0 0 0; overflow-x: auto; font-size: 0.875rem; line-height: 1.4;">${this.escapeHtml(diff.diff || 'No diff available')}</pre>
                                        </div>
                                    </div>
                                    <details style="margin-top: 1rem;">
                                        <summary style="cursor: pointer; color: #667eea; font-weight: 500;">Show Full Comparison</summary>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                                            <div>
                                                <div style="background: #ffebee; padding: 0.5rem; font-weight: 500; border-bottom: 2px solid #ef5350;">Expected (Snapshot)</div>
                                                <pre style="margin: 0; padding: 1rem; overflow-x: auto; background: #fff; border: 1px solid #ffcdd2; font-size: 0.875rem; max-height: 400px; overflow-y: auto;">${this.escapeHtml(diff.expected)}</pre>
                                            </div>
                                            <div>
                                                <div style="background: #e8f5e9; padding: 0.5rem; font-weight: 500; border-bottom: 2px solid #66bb6a;">Actual (Current)</div>
                                                <pre style="margin: 0; padding: 1rem; overflow-x: auto; background: #fff; border: 1px solid #c8e6c9; font-size: 0.875rem; max-height: 400px; overflow-y: auto;">${this.escapeHtml(diff.actual)}</pre>
                                            </div>
                                        </div>
                                    </details>
                                </div>
                            </div>`;
                    });

                    html += `
                            <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 1rem; margin-top: 1rem; border-radius: 4px;">
                                <strong>üí° To update snapshots:</strong><br>
                                Run tests with: <code style="background: #fff; padding: 0.25rem 0.5rem; border-radius: 3px;">UPDATE_SNAPSHOTS=true npm test</code>
                            </div>
                        </div>`;
                }

                if (!result.passed || hasSnapshotMismatch) {
                    html += `
                        <div class="tab-content" id="${detailsId}-issues">`;

                    if (result.parseErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Parse Errors</h4>
                            <ul class="error-list">${result.parseErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.validationErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Validation Errors</h4>
                            <ul class="error-list">${result.validationErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.transformErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Transform Errors</h4>
                            <ul class="error-list">${result.transformErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.completenessIssues.length > 0) {
                        html += `<div class="error-section">
                            <h4>Completeness Issues</h4>
                            <ul class="error-list">${result.completenessIssues.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.losslessnessIssues.length > 0) {
                        html += `<div class="error-section">
                            <h4>Losslessness Issues</h4>
                            <ul class="error-list">${result.losslessnessIssues.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.graphvizParseErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Graphviz Parse Errors</h4>
                            <ul class="error-list">${result.graphvizParseErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.svgRenderErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>SVG Render Errors</h4>
                            <ul class="error-list">${result.svgRenderErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.dslRoundTripErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>DSL Round-trip Errors</h4>
                            <ul class="error-list">${result.dslRoundTripErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.snapshotMismatches.length > 0) {
                        const isInfoOnly = result.passed;
                        html += `<div class="${isInfoOnly ? 'warning-section' : 'error-section'}">
                            <h4>Snapshot ${isInfoOnly ? 'Information' : 'Mismatches'}</h4>
                            <ul class="error-list ${isInfoOnly ? 'warning-list' : ''}">${result.snapshotMismatches.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }

                    html += `</div>`;
                }

                html += `
                        <p style="margin-top: 1rem;"><a href="${category}/${fileName}.md" target="_blank">View Markdown Report ‚Üí</a></p>
                    </div>
                </div>`;
            });

            html += `
            </div>
        </div>`;
        });

        html += `
    </div>
</body>
</html>`;

        return html;
    }

    private escapeHtml(text: string): string {
        const map: Record<string, string> = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    writeReport(): void {
        const report = this.generateReport();
        const htmlReport = this.generateHtmlReport();

        fs.writeFileSync(path.join(this.outputDir, 'REPORT.md'), report);
        fs.writeFileSync(path.join(this.outputDir, 'index.html'), htmlReport);

        // Check if we're in verbose mode
        const isVerbose = process.env.VERBOSE_TESTS === 'true';

        if (isVerbose) {
            console.log(`\nüìä Comprehensive test report written to: ${path.join(this.outputDir, 'REPORT.md')}`);
            console.log(`üåê HTML report available at: ${path.join(this.outputDir, 'index.html')}`);
            console.log(`üìÅ Individual test outputs: ${this.outputDir}\n`);
        } else {
            // Minimal output: just show the HTML report location
            const total = this.results.length;
            const passed = this.results.filter(r => r.passed).length;
            const failed = total - passed;

            console.log(`\nüìä Comprehensive Generative Tests: ${passed}/${total} passed`);
            if (failed > 0) {
                console.log(`   ‚ùå ${failed} test(s) failed - see HTML report for details`);
            }
            console.log(`   üåê Full report: ${path.join(this.outputDir, 'index.html')}\n`);
        }
    }
}

describe('Comprehensive Generative Integration Tests', () => {
    const reporter = new ValidationReporter();
    const snapshotManager = new SnapshotManager();

    // Determine if we should minimize output (default: yes, unless VERBOSE_TESTS is set)
    const isVerbose = process.env.VERBOSE_TESTS === 'true';

    // Log snapshot mode at the start (only if verbose)
    if (isVerbose) {
        if (snapshotManager.shouldUpdateSnapshots()) {
            console.log('üîÑ Running in SNAPSHOT UPDATE mode. Snapshots will be created/updated.');
        } else {
            console.log('üì∏ Running in SNAPSHOT COMPARISON mode. Tests will fail if outputs differ from snapshots.');
            console.log('üí° To update snapshots, run: UPDATE_SNAPSHOTS=true npm test');
        }
    }

    const runGenerativeTest = async (example: typeof examplesList[0]) => {
        const result: ValidationResult = {
            testName: example.name,
            category: example.category,
            path: example.path,
            source: example.content,
            passed: true,
            parseErrors: [],
            validationErrors: [],
            transformErrors: [],
            completenessIssues: [],
            losslessnessIssues: [],
            graphvizParseErrors: [],
            svgRenderErrors: [],
            dslRoundTripErrors: [],
            snapshotMismatches: [],
            snapshotDiffs: []
        };

        try {
            // Parse
            const document = await parse(example.content);

            // Check for parse errors
            if (document.parseResult.parserErrors.length > 0) {
                result.parseErrors = document.parseResult.parserErrors.map(e => e.message);
                result.passed = false;
            }

            if (document.parseResult.lexerErrors.length > 0) {
                result.parseErrors.push(...document.parseResult.lexerErrors.map(e => e.message));
                result.passed = false;
            }

            // Check for validation errors (semantic/type errors)
            if (document.diagnostics && document.diagnostics.length > 0) {
                result.validationErrors = document.diagnostics
                    .filter(d => d.severity === 1) // 1 = Error severity
                    .map(d => d.message);

                if (result.validationErrors.length > 0) {
                    result.passed = false;
                }
            }

            if (!isMachine(document.parseResult.value)) {
                result.parseErrors.push('Parsed value is not a Machine');
                result.passed = false;
                reporter.addResult(result);
                return result;
            }

            const machine = document.parseResult.value as Machine;

            // Transform to JSON
            try {
                const jsonResult = generateJSON(machine, example.filename, undefined);
                result.jsonOutput = JSON.parse(jsonResult.content);

                // Validate completeness: all nodes should be in JSON
                const sourceNodeNames = extractNodeNamesFromSource(example.content);
                const jsonNodeNames = result.jsonOutput.nodes.map((n: any) => n.name);

                for (const nodeName of sourceNodeNames) {
                    if (!jsonNodeNames.includes(nodeName)) {
                        result.completenessIssues.push(`Node "${nodeName}" from source not found in JSON output`);
                        result.passed = false;
                    }
                }

                // Check edge preservation
                const sourceEdgeCount = (example.content.match(/->/g) || []).length +
                                      (example.content.match(/-->/g) || []).length +
                                      (example.content.match(/=>/g) || []).length +
                                      (example.content.match(/<-->/g) || []).length;

                if (sourceEdgeCount > 0 && result.jsonOutput.edges.length === 0) {
                    result.completenessIssues.push(`Source has ${sourceEdgeCount} edges, but JSON has none`);
                    result.passed = false;
                }

            } catch (e) {
                result.transformErrors.push(`JSON generation failed: ${e}`);
                result.passed = false;
            }

            // Transform to Graphviz
            try {
                const graphvizResult = generateGraphviz(machine, example.filename, undefined);
                result.graphvizOutput = graphvizResult.content;

                // Validate Graphviz contains key elements
                if (!result.graphvizOutput.includes('digraph')) {
                    result.losslessnessIssues.push('Graphviz output missing digraph declaration');
                    result.passed = false;
                }

                if (machine.title && !result.graphvizOutput.includes(machine.title)) {
                    result.losslessnessIssues.push(`Graphviz output missing machine title: "${machine.title}"`);
                    result.passed = false;
                }

                // Check that nodes appear in Graphviz
                const sourceNodeNames = extractNodeNamesFromSource(example.content);
                for (const nodeName of sourceNodeNames) {
                    if (!result.graphvizOutput.includes(nodeName)) {
                        result.losslessnessIssues.push(`Node "${nodeName}" not found in Graphviz output`);
                        result.passed = false;
                    }
                }

                // Basic DOT syntax validation
                // Check for balanced braces
                const openBraces = (result.graphvizOutput.match(/\{/g) || []).length;
                const closeBraces = (result.graphvizOutput.match(/\}/g) || []).length;
                if (openBraces !== closeBraces) {
                    result.graphvizParseErrors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
                    result.passed = false;
                }

                // NEW: Render to SVG
                try {
                    result.svgOutput = await renderDotToSVG(result.graphvizOutput);

                    // Validate SVG output
                    if (!result.svgOutput || result.svgOutput.length === 0) {
                        result.svgRenderErrors.push('SVG output is empty');
                        result.passed = false;
                    } else if (!result.svgOutput.includes('<svg')) {
                        result.svgRenderErrors.push('SVG output does not contain <svg> tag');
                        result.passed = false;
                    } else if (!result.svgOutput.includes('</svg>')) {
                        result.svgRenderErrors.push('SVG output is incomplete (missing closing tag)');
                        result.passed = false;
                    }

                    // Basic SVG structure validation
                    if (result.svgOutput) {
                        const svgOpenTags = (result.svgOutput.match(/<svg[^>]*>/g) || []).length;
                        const svgCloseTags = (result.svgOutput.match(/<\/svg>/g) || []).length;
                        if (svgOpenTags !== svgCloseTags) {
                            result.svgRenderErrors.push(`Unbalanced SVG tags: ${svgOpenTags} open, ${svgCloseTags} close`);
                            result.passed = false;
                        }
                    }
                } catch (e) {
                    result.svgRenderErrors.push(`SVG rendering failed: ${e}`);
                    result.passed = false;
                }

            } catch (e) {
                result.transformErrors.push(`Graphviz generation failed: ${e}`);
                result.passed = false;
            }

            // NEW: DSL Round-trip testing (JSON ‚Üí DSL ‚Üí JSON)
            if (result.jsonOutput) {
                try {
                    result.dslOutput = generateDSL(result.jsonOutput);

                    // Parse the regenerated DSL
                    const roundTripDoc = await parse(result.dslOutput);

                    // Check for parse errors in round-trip
                    if (roundTripDoc.parseResult.parserErrors.length > 0) {
                        result.dslRoundTripErrors.push(
                            `Round-trip DSL has parse errors: ${roundTripDoc.parseResult.parserErrors.map(e => e.message).join(', ')}`
                        );
                        result.passed = false;
                    }

                    if (roundTripDoc.parseResult.lexerErrors.length > 0) {
                        result.dslRoundTripErrors.push(
                            `Round-trip DSL has lexer errors: ${roundTripDoc.parseResult.lexerErrors.map(e => e.message).join(', ')}`
                        );
                        result.passed = false;
                    }

                    // If parse succeeded, convert back to JSON and compare
                    if (isMachine(roundTripDoc.parseResult.value)) {
                        const roundTripMachine = roundTripDoc.parseResult.value as Machine;
                        const roundTripJsonResult = generateJSON(roundTripMachine, example.filename, undefined);
                        const roundTripJson = JSON.parse(roundTripJsonResult.content);

                        // Deep compare JSON structures (DSL‚ÜíJSON1‚ÜíDSL2‚ÜíJSON2, check JSON1 === JSON2)
                        // This ensures lossless transformation, ignoring formatting differences
                        const jsonDifferences = deepCompareJSON(result.jsonOutput, roundTripJson, 'json');

                        if (jsonDifferences.length > 0) {
                            result.dslRoundTripErrors.push(
                                `Round-trip JSON mismatch (DSL‚ÜíJSON‚ÜíDSL‚ÜíJSON should be lossless):`
                            );
                            // Report first 10 differences to avoid overwhelming output
                            const limitedDiffs = jsonDifferences.slice(0, 10);
                            result.dslRoundTripErrors.push(...limitedDiffs.map(d => `  - ${d}`));

                            if (jsonDifferences.length > 10) {
                                result.dslRoundTripErrors.push(
                                    `  ... and ${jsonDifferences.length - 10} more difference(s)`
                                );
                            }
                            result.passed = false;
                        }
                    }
                } catch (e) {
                    result.dslRoundTripErrors.push(`DSL round-trip failed: ${e}`);
                    result.passed = false;
                }
            }

            // NEW: Snapshot comparison
            // Only compare snapshots if we have all outputs successfully generated
            if (result.jsonOutput && result.graphvizOutput && result.svgOutput) {
                try {
                    const snapshotComparison = snapshotManager.compareWithSnapshot(
                        example.name,
                        example.category,
                        result.jsonOutput,
                        result.graphvizOutput,
                        result.svgOutput
                    );

                    // Store the detailed diffs
                    result.snapshotDiffs = snapshotComparison.diffs;

                    // Only fail if there are actual differences AND we're not in update mode
                    const actualDifferences = snapshotComparison.differences.filter(
                        d => !d.includes('snapshot created') && !d.includes('Snapshot updated')
                    );

                    if (actualDifferences.length > 0 && !snapshotManager.shouldUpdateSnapshots()) {
                        // Real mismatches that should fail the test
                        result.snapshotMismatches = snapshotComparison.differences;
                        result.passed = false;
                    } else if (snapshotComparison.differences.length > 0) {
                        // Just informational messages (creation/update messages)
                        result.snapshotMismatches = snapshotComparison.differences;
                    }
                } catch (e) {
                    result.snapshotMismatches.push(`Snapshot comparison failed: ${e}`);
                    result.passed = false;
                }
            }

        } catch (e) {
            result.transformErrors.push(`Unexpected error: ${e}`);
            result.passed = false;
        }

        reporter.addResult(result);
        return result;
    };

    /**
     * Deep comparison of two JSON objects with normalization for arrays
     * Returns an array of difference descriptions, or empty array if equal
     */
    const deepCompareJSON = (obj1: any, obj2: any, path: string = 'root'): string[] => {
        const differences: string[] = [];

        // Handle null/undefined
        if (obj1 == null && obj2 == null) return [];
        if (obj1 == null) {
            differences.push(`${path}: first is null/undefined, second is ${typeof obj2}`);
            return differences;
        }
        if (obj2 == null) {
            differences.push(`${path}: first is ${typeof obj1}, second is null/undefined`);
            return differences;
        }

        // Handle type differences
        if (typeof obj1 !== typeof obj2) {
            differences.push(`${path}: type mismatch (${typeof obj1} vs ${typeof obj2})`);
            return differences;
        }

        // Handle primitives
        if (typeof obj1 !== 'object') {
            if (obj1 !== obj2) {
                differences.push(`${path}: value mismatch (${obj1} vs ${obj2})`);
            }
            return differences;
        }

        // Handle arrays
        if (Array.isArray(obj1) && Array.isArray(obj2)) {
            if (obj1.length !== obj2.length) {
                differences.push(`${path}: array length mismatch (${obj1.length} vs ${obj2.length})`);
                return differences;
            }

            // For arrays of objects with 'name' field, compare by name (order-independent)
            const hasNameField = obj1.length > 0 && obj1[0]?.name !== undefined;
            if (hasNameField) {
                const map1 = new Map(obj1.map((item: any) => [item.name, item]));
                const map2 = new Map(obj2.map((item: any) => [item.name, item]));

                // Check all names exist in both
                for (const name of map1.keys()) {
                    if (!map2.has(name)) {
                        differences.push(`${path}: item "${name}" exists in first but not in second`);
                    }
                }
                for (const name of map2.keys()) {
                    if (!map1.has(name)) {
                        differences.push(`${path}: item "${name}" exists in second but not in first`);
                    }
                }

                // Deep compare matching items
                for (const [name, item1] of map1.entries()) {
                    const item2 = map2.get(name);
                    if (item2) {
                        differences.push(...deepCompareJSON(item1, item2, `${path}[name="${name}"]`));
                    }
                }
            } else {
                // For other arrays, compare by index
                for (let i = 0; i < obj1.length; i++) {
                    differences.push(...deepCompareJSON(obj1[i], obj2[i], `${path}[${i}]`));
                }
            }

            return differences;
        }

        // Handle objects
        if (Array.isArray(obj1) !== Array.isArray(obj2)) {
            differences.push(`${path}: type mismatch (array vs object)`);
            return differences;
        }

        // Compare object keys
        const keys1 = Object.keys(obj1).sort();
        const keys2 = Object.keys(obj2).sort();

        // Check for missing keys
        for (const key of keys1) {
            if (!keys2.includes(key)) {
                differences.push(`${path}.${key}: exists in first but not in second`);
            }
        }
        for (const key of keys2) {
            if (!keys1.includes(key)) {
                differences.push(`${path}.${key}: exists in second but not in first`);
            }
        }

        // Deep compare common keys
        const commonKeys = keys1.filter(k => keys2.includes(k));
        for (const key of commonKeys) {
            differences.push(...deepCompareJSON(obj1[key], obj2[key], `${path}.${key}`));
        }

        return differences;
    };

    // Helper to extract node names from source
    const extractNodeNamesFromSource = (source: string): string[] => {
        const names: string[] = [];
        const excludedKeywords = ['machine', 'note', 'workflow', 'import'];

        // Match simple node declarations: nodeName;
        const simpleMatches = source.matchAll(/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*;/gm);
        for (const match of simpleMatches) {
            if (!excludedKeywords.includes(match[1])) {
                names.push(match[1]);
            }
        }

        // Match typed nodes: type nodeName;
        const typedMatches = source.matchAll(/^\s*(?:task|state|init|context|workflow|Task|State|Init|Context|Input|Result|Concept)\s+([a-zA-Z_][a-zA-Z0-9_]*)/gmi);
        for (const match of typedMatches) {
            names.push(match[1]);
        }

        // Match nodes with attributes: nodeName { ... }
        const attrMatches = source.matchAll(/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/gm);
        for (const match of attrMatches) {
            if (!excludedKeywords.includes(match[1])) {
                names.push(match[1]);
            }
        }

        return [...new Set(names)]; // Remove duplicates
    };

    // Generate tests for all examples programmatically
    examplesList.forEach((example) => {
        test(`${example.category}/${example.name}`, async () => {
            const result = await runGenerativeTest(example);
            expect(result.passed).toBe(true);
        });
    });

    // Write report after all tests
    test('Generate Comprehensive Report', () => {
        reporter.writeReport();
        expect(true).toBe(true);
    });
});
