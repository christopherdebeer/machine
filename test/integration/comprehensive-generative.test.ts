import { beforeAll, describe, expect, test } from "vitest";
import { EmptyFileSystem } from "langium";
import { parseHelper } from "langium/test";
import { createMachineServices } from "../../src/language/machine-module.js";
import { Machine, isMachine } from "../../src/language/generated/ast.js";
import { generateJSON, generateGraphviz } from "../../src/language/generator/generator.js";
import { renderDotToSVG } from "../../src/language/diagram/graphviz-generator.js";
import * as fs from "node:fs";
import * as path from "node:path";
import * as crypto from "node:crypto";

// Import the examples list generated by prebuild
import examplesList from "../../src/generated/examples-list.json" assert { type: "json" };

let services: ReturnType<typeof createMachineServices>;
let parse: ReturnType<typeof parseHelper<Machine>>;

beforeAll(async () => {
    services = createMachineServices(EmptyFileSystem);
    parse = parseHelper<Machine>(services.Machine);
});

/**
 * Comprehensive Generative Integration Test Suite
 *
 * This test suite programmatically iterates over ALL extracted examples
 * from the build process and validates:
 * 1. Parsing (no lexer/parser errors)
 * 2. JSON generation (completeness)
 * 3. Graphviz DOT generation (losslessness)
 * 4. SVG rendering (renderability)
 *
 * Examples are loaded from src/generated/examples-list.json which is
 * generated by scripts/prebuild.js from markdown documentation.
 */

interface ValidationResult {
    testName: string;
    category: string;
    path: string;
    source: string;
    passed: boolean;
    parseErrors: string[];
    transformErrors: string[];
    completenessIssues: string[];
    losslessnessIssues: string[];
    graphvizParseErrors: string[];
    svgRenderErrors: string[];
    snapshotMismatches: string[];
    jsonOutput?: any;
    graphvizOutput?: string;
    svgOutput?: string;
}

/**
 * Snapshot Manager
 *
 * Manages snapshot storage, comparison, and updates for test outputs.
 * Snapshots are stored in test/integration/__snapshots__/ and tracked in git.
 */
class SnapshotManager {
    private snapshotDir: string;
    private updateSnapshots: boolean;

    constructor() {
        this.snapshotDir = path.join(process.cwd(), 'test', 'integration', '__snapshots__');
        // Check for UPDATE_SNAPSHOTS environment variable
        this.updateSnapshots = process.env.UPDATE_SNAPSHOTS === 'true';

        if (!fs.existsSync(this.snapshotDir)) {
            fs.mkdirSync(this.snapshotDir, { recursive: true });
        }
    }

    /**
     * Get the snapshot file path for a given test
     */
    private getSnapshotPath(testName: string, category: string): string {
        const sanitizedCategory = category.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const sanitizedName = testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        return path.join(this.snapshotDir, `${sanitizedCategory}_${sanitizedName}.json`);
    }

    /**
     * Generate a hash of content for quick comparison
     */
    private hashContent(content: string): string {
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    /**
     * Load existing snapshot for a test, if it exists
     */
    loadSnapshot(testName: string, category: string): any | null {
        const snapshotPath = this.getSnapshotPath(testName, category);
        if (!fs.existsSync(snapshotPath)) {
            return null;
        }
        try {
            const content = fs.readFileSync(snapshotPath, 'utf-8');
            return JSON.parse(content);
        } catch (e) {
            console.warn(`Failed to load snapshot for ${testName}: ${e}`);
            return null;
        }
    }

    /**
     * Save a snapshot for a test
     */
    saveSnapshot(testName: string, category: string, snapshot: any): void {
        const snapshotPath = this.getSnapshotPath(testName, category);
        fs.writeFileSync(snapshotPath, JSON.stringify(snapshot, null, 2), 'utf-8');
    }

    /**
     * Compare current outputs against snapshot and return differences
     */
    compareWithSnapshot(
        testName: string,
        category: string,
        jsonOutput: any,
        graphvizOutput: string,
        svgOutput: string
    ): string[] {
        const differences: string[] = [];
        const snapshot = this.loadSnapshot(testName, category);

        if (!snapshot) {
            if (this.updateSnapshots) {
                // Create new snapshot
                this.saveSnapshot(testName, category, {
                    json: jsonOutput,
                    graphviz: graphvizOutput,
                    svgHash: this.hashContent(svgOutput)
                });
                differences.push('New snapshot created');
            } else {
                differences.push('No baseline snapshot found. Run tests with UPDATE_SNAPSHOTS=true to create snapshots.');
            }
            return differences;
        }

        // Compare JSON output
        const currentJsonStr = JSON.stringify(jsonOutput, null, 2);
        const snapshotJsonStr = JSON.stringify(snapshot.json, null, 2);
        if (currentJsonStr !== snapshotJsonStr) {
            differences.push('JSON output differs from snapshot');
        }

        // Compare Graphviz output
        if (graphvizOutput !== snapshot.graphviz) {
            differences.push('Graphviz DOT output differs from snapshot');
        }

        // Compare SVG output (using hash for efficiency)
        const currentSvgHash = this.hashContent(svgOutput);
        if (currentSvgHash !== snapshot.svgHash) {
            differences.push('SVG output differs from snapshot');
        }

        // Update snapshot if requested
        if (differences.length > 0 && this.updateSnapshots) {
            this.saveSnapshot(testName, category, {
                json: jsonOutput,
                graphviz: graphvizOutput,
                svgHash: currentSvgHash
            });
            differences.push('Snapshot updated');
        }

        return differences;
    }

    /**
     * Get all snapshot files
     */
    getAllSnapshots(): string[] {
        if (!fs.existsSync(this.snapshotDir)) {
            return [];
        }
        return fs.readdirSync(this.snapshotDir)
            .filter(file => file.endsWith('.json'))
            .map(file => path.join(this.snapshotDir, file));
    }

    /**
     * Check if snapshots should be updated
     */
    shouldUpdateSnapshots(): boolean {
        return this.updateSnapshots;
    }
}

class ValidationReporter {
    private results: ValidationResult[] = [];
    private outputDir = path.join(process.cwd(), 'test-output', 'comprehensive-generative');

    constructor() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    addResult(result: ValidationResult): void {
        this.results.push(result);

        // Write individual outputs for manual inspection
        const fileName = result.testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const categoryDir = path.join(this.outputDir, result.category);

        if (!fs.existsSync(categoryDir)) {
            fs.mkdirSync(categoryDir, { recursive: true });
        }

        // Write markdown report
        let mdContent = `# ${result.testName}\n\n`;
        mdContent += `**Category**: ${result.category}\n`;
        mdContent += `**Path**: ${result.path}\n`;
        mdContent += `**Status**: ${result.passed ? '✅ PASSED' : '❌ FAILED'}\n\n`;

        mdContent += `## Source\n\`\`\`dygram\n${result.source}\n\`\`\`\n\n`;

        if (result.jsonOutput) {
            mdContent += `## JSON Output\n\`\`\`json\n${JSON.stringify(result.jsonOutput, null, 2)}\n\`\`\`\n\n`;
        }

        if (result.graphvizOutput) {
            mdContent += `## Graphviz DOT Output\n\`\`\`dot\n${result.graphvizOutput}\n\`\`\`\n\n`;
        }

        mdContent += `## Validation Results\n`;
        mdContent += `- Parse Errors: ${result.parseErrors.length}\n`;
        mdContent += `- Transform Errors: ${result.transformErrors.length}\n`;
        mdContent += `- Completeness Issues: ${result.completenessIssues.length}\n`;
        mdContent += `- Losslessness Issues: ${result.losslessnessIssues.length}\n`;
        mdContent += `- Graphviz Parse Errors: ${result.graphvizParseErrors.length}\n`;
        mdContent += `- SVG Render Errors: ${result.svgRenderErrors.length}\n`;
        mdContent += `- Snapshot Mismatches: ${result.snapshotMismatches.length}\n\n`;

        if (result.parseErrors.length > 0) {
            mdContent += `### Parse Errors\n${result.parseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.transformErrors.length > 0) {
            mdContent += `### Transform Errors\n${result.transformErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.completenessIssues.length > 0) {
            mdContent += `### Completeness Issues\n${result.completenessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.losslessnessIssues.length > 0) {
            mdContent += `### Losslessness Issues\n${result.losslessnessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.graphvizParseErrors.length > 0) {
            mdContent += `### Graphviz Parse Errors\n${result.graphvizParseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.svgRenderErrors.length > 0) {
            mdContent += `### SVG Render Errors\n${result.svgRenderErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.snapshotMismatches.length > 0) {
            mdContent += `### Snapshot Mismatches\n${result.snapshotMismatches.map(e => `- ${e}`).join('\n')}\n\n`;
        }

        fs.writeFileSync(path.join(categoryDir, `${fileName}.md`), mdContent);

        // Write SVG if it was successfully generated
        if (result.svgOutput && result.svgRenderErrors.length === 0) {
            fs.writeFileSync(path.join(categoryDir, `${fileName}.svg`), result.svgOutput);
        }
    }

    generateReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.passed).length;
        const failed = total - passed;

        let report = `# Comprehensive Generative Test Report\n\n`;
        report += `Generated: ${new Date().toISOString()}\n\n`;
        report += `## Summary\n`;
        report += `- Total Tests: ${total}\n`;
        report += `- Passed: ${passed}\n`;
        report += `- Failed: ${failed}\n`;
        report += `- Success Rate: ${((passed / total) * 100).toFixed(2)}%\n\n`;

        // Group by category
        const byCategory: Record<string, { total: number; passed: number }> = {};
        this.results.forEach(r => {
            if (!byCategory[r.category]) {
                byCategory[r.category] = { total: 0, passed: 0 };
            }
            byCategory[r.category].total++;
            if (r.passed) byCategory[r.category].passed++;
        });

        report += `## Results by Category\n`;
        Object.keys(byCategory).sort().forEach(category => {
            const { total, passed } = byCategory[category];
            const rate = ((passed / total) * 100).toFixed(1);
            report += `- **${category}**: ${passed}/${total} (${rate}%)\n`;
        });
        report += `\n`;

        // Group issues by type
        const allParseErrors = this.results.flatMap(r => r.parseErrors);
        const allTransformErrors = this.results.flatMap(r => r.transformErrors);
        const allCompletenessIssues = this.results.flatMap(r => r.completenessIssues);
        const allLosslessnessIssues = this.results.flatMap(r => r.losslessnessIssues);
        const allGraphvizParseErrors = this.results.flatMap(r => r.graphvizParseErrors);
        const allSvgRenderErrors = this.results.flatMap(r => r.svgRenderErrors);
        const allSnapshotMismatches = this.results.flatMap(r => r.snapshotMismatches);

        report += `## Issue Summary\n`;
        report += `- Parse Errors: ${allParseErrors.length}\n`;
        report += `- Transform Errors: ${allTransformErrors.length}\n`;
        report += `- Completeness Issues: ${allCompletenessIssues.length}\n`;
        report += `- Losslessness Issues: ${allLosslessnessIssues.length}\n`;
        report += `- Graphviz Parse Errors: ${allGraphvizParseErrors.length}\n`;
        report += `- SVG Render Errors: ${allSvgRenderErrors.length}\n`;
        report += `- Snapshot Mismatches: ${allSnapshotMismatches.length}\n\n`;

        // Failed tests details
        const failedResults = this.results.filter(r => !r.passed);
        if (failedResults.length > 0) {
            report += `## Failed Tests (${failedResults.length})\n\n`;
            failedResults.forEach(r => {
                report += `### ${r.testName} (${r.category})\n`;
                report += `Path: ${r.path}\n\n`;
                if (r.parseErrors.length > 0) {
                    report += `**Parse Errors:**\n${r.parseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.transformErrors.length > 0) {
                    report += `**Transform Errors:**\n${r.transformErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.completenessIssues.length > 0) {
                    report += `**Completeness Issues:**\n${r.completenessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.losslessnessIssues.length > 0) {
                    report += `**Losslessness Issues:**\n${r.losslessnessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.graphvizParseErrors.length > 0) {
                    report += `**Graphviz Parse Errors:**\n${r.graphvizParseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.svgRenderErrors.length > 0) {
                    report += `**SVG Render Errors:**\n${r.svgRenderErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.snapshotMismatches.length > 0) {
                    report += `**Snapshot Mismatches:**\n${r.snapshotMismatches.map(e => `- ${e}`).join('\n')}\n\n`;
                }
            });
        }

        return report;
    }

    writeReport(): void {
        const report = this.generateReport();
        fs.writeFileSync(path.join(this.outputDir, 'REPORT.md'), report);
        console.log(`\n📊 Comprehensive test report written to: ${path.join(this.outputDir, 'REPORT.md')}`);
        console.log(`📁 Individual test outputs: ${this.outputDir}\n`);
    }
}

describe('Comprehensive Generative Integration Tests', () => {
    const reporter = new ValidationReporter();
    const snapshotManager = new SnapshotManager();

    // Log snapshot mode at the start
    if (snapshotManager.shouldUpdateSnapshots()) {
        console.log('🔄 Running in SNAPSHOT UPDATE mode. Snapshots will be created/updated.');
    } else {
        console.log('📸 Running in SNAPSHOT COMPARISON mode. Tests will fail if outputs differ from snapshots.');
        console.log('💡 To update snapshots, run: UPDATE_SNAPSHOTS=true npm test');
    }

    const runGenerativeTest = async (example: typeof examplesList[0]) => {
        const result: ValidationResult = {
            testName: example.name,
            category: example.category,
            path: example.path,
            source: example.content,
            passed: true,
            parseErrors: [],
            transformErrors: [],
            completenessIssues: [],
            losslessnessIssues: [],
            graphvizParseErrors: [],
            svgRenderErrors: [],
            snapshotMismatches: []
        };

        try {
            // Parse
            const document = await parse(example.content);

            // Check for parse errors
            if (document.parseResult.parserErrors.length > 0) {
                result.parseErrors = document.parseResult.parserErrors.map(e => e.message);
                result.passed = false;
            }

            if (document.parseResult.lexerErrors.length > 0) {
                result.parseErrors.push(...document.parseResult.lexerErrors.map(e => e.message));
                result.passed = false;
            }

            if (!isMachine(document.parseResult.value)) {
                result.parseErrors.push('Parsed value is not a Machine');
                result.passed = false;
                reporter.addResult(result);
                return result;
            }

            const machine = document.parseResult.value as Machine;

            // Transform to JSON
            try {
                const jsonResult = generateJSON(machine, example.filename, undefined);
                result.jsonOutput = JSON.parse(jsonResult.content);

                // Validate completeness: all nodes should be in JSON
                const sourceNodeNames = extractNodeNamesFromSource(example.content);
                const jsonNodeNames = result.jsonOutput.nodes.map((n: any) => n.name);

                for (const nodeName of sourceNodeNames) {
                    if (!jsonNodeNames.includes(nodeName)) {
                        result.completenessIssues.push(`Node "${nodeName}" from source not found in JSON output`);
                        result.passed = false;
                    }
                }

                // Check edge preservation
                const sourceEdgeCount = (example.content.match(/->/g) || []).length +
                                      (example.content.match(/-->/g) || []).length +
                                      (example.content.match(/=>/g) || []).length +
                                      (example.content.match(/<-->/g) || []).length;

                if (sourceEdgeCount > 0 && result.jsonOutput.edges.length === 0) {
                    result.completenessIssues.push(`Source has ${sourceEdgeCount} edges, but JSON has none`);
                    result.passed = false;
                }

            } catch (e) {
                result.transformErrors.push(`JSON generation failed: ${e}`);
                result.passed = false;
            }

            // Transform to Graphviz
            try {
                const graphvizResult = generateGraphviz(machine, example.filename, undefined);
                result.graphvizOutput = graphvizResult.content;

                // Validate Graphviz contains key elements
                if (!result.graphvizOutput.includes('digraph')) {
                    result.losslessnessIssues.push('Graphviz output missing digraph declaration');
                    result.passed = false;
                }

                if (machine.title && !result.graphvizOutput.includes(machine.title)) {
                    result.losslessnessIssues.push(`Graphviz output missing machine title: "${machine.title}"`);
                    result.passed = false;
                }

                // Check that nodes appear in Graphviz
                const sourceNodeNames = extractNodeNamesFromSource(example.content);
                for (const nodeName of sourceNodeNames) {
                    if (!result.graphvizOutput.includes(nodeName)) {
                        result.losslessnessIssues.push(`Node "${nodeName}" not found in Graphviz output`);
                        result.passed = false;
                    }
                }

                // Basic DOT syntax validation
                // Check for balanced braces
                const openBraces = (result.graphvizOutput.match(/\{/g) || []).length;
                const closeBraces = (result.graphvizOutput.match(/\}/g) || []).length;
                if (openBraces !== closeBraces) {
                    result.graphvizParseErrors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
                    result.passed = false;
                }

                // NEW: Render to SVG
                try {
                    result.svgOutput = await renderDotToSVG(result.graphvizOutput);

                    // Validate SVG output
                    if (!result.svgOutput || result.svgOutput.length === 0) {
                        result.svgRenderErrors.push('SVG output is empty');
                        result.passed = false;
                    } else if (!result.svgOutput.includes('<svg')) {
                        result.svgRenderErrors.push('SVG output does not contain <svg> tag');
                        result.passed = false;
                    } else if (!result.svgOutput.includes('</svg>')) {
                        result.svgRenderErrors.push('SVG output is incomplete (missing closing tag)');
                        result.passed = false;
                    }

                    // Basic SVG structure validation
                    if (result.svgOutput) {
                        const svgOpenTags = (result.svgOutput.match(/<svg[^>]*>/g) || []).length;
                        const svgCloseTags = (result.svgOutput.match(/<\/svg>/g) || []).length;
                        if (svgOpenTags !== svgCloseTags) {
                            result.svgRenderErrors.push(`Unbalanced SVG tags: ${svgOpenTags} open, ${svgCloseTags} close`);
                            result.passed = false;
                        }
                    }
                } catch (e) {
                    result.svgRenderErrors.push(`SVG rendering failed: ${e}`);
                    result.passed = false;
                }

            } catch (e) {
                result.transformErrors.push(`Graphviz generation failed: ${e}`);
                result.passed = false;
            }

            // NEW: Snapshot comparison
            // Only compare snapshots if we have all outputs successfully generated
            if (result.jsonOutput && result.graphvizOutput && result.svgOutput) {
                try {
                    const snapshotDifferences = snapshotManager.compareWithSnapshot(
                        example.name,
                        example.category,
                        result.jsonOutput,
                        result.graphvizOutput,
                        result.svgOutput
                    );

                    // Only fail if there are actual differences (not just creation/update messages)
                    const actualDifferences = snapshotDifferences.filter(
                        d => !d.includes('snapshot created') && !d.includes('Snapshot updated')
                    );

                    if (actualDifferences.length > 0) {
                        result.snapshotMismatches = snapshotDifferences;
                        result.passed = false;
                    } else if (snapshotDifferences.length > 0) {
                        // Just informational messages
                        result.snapshotMismatches = snapshotDifferences;
                    }
                } catch (e) {
                    result.snapshotMismatches.push(`Snapshot comparison failed: ${e}`);
                    result.passed = false;
                }
            }

        } catch (e) {
            result.transformErrors.push(`Unexpected error: ${e}`);
            result.passed = false;
        }

        reporter.addResult(result);
        return result;
    };

    // Helper to extract node names from source
    const extractNodeNamesFromSource = (source: string): string[] => {
        const names: string[] = [];
        const excludedKeywords = ['machine', 'note', 'workflow'];

        // Match simple node declarations: nodeName;
        const simpleMatches = source.matchAll(/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*;/gm);
        for (const match of simpleMatches) {
            if (!excludedKeywords.includes(match[1])) {
                names.push(match[1]);
            }
        }

        // Match typed nodes: type nodeName;
        const typedMatches = source.matchAll(/^\s*(?:task|state|init|context|workflow|Task|State|Init|Context|Input|Result|Concept)\s+([a-zA-Z_][a-zA-Z0-9_]*)/gmi);
        for (const match of typedMatches) {
            names.push(match[1]);
        }

        // Match nodes with attributes: nodeName { ... }
        const attrMatches = source.matchAll(/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/gm);
        for (const match of attrMatches) {
            if (!excludedKeywords.includes(match[1])) {
                names.push(match[1]);
            }
        }

        return [...new Set(names)]; // Remove duplicates
    };

    // Generate tests for all examples programmatically
    examplesList.forEach((example) => {
        test(`${example.category}/${example.name}`, async () => {
            const result = await runGenerativeTest(example);
            expect(result.passed).toBe(true);
        });
    });

    // Write report after all tests
    test('Generate Comprehensive Report', () => {
        reporter.writeReport();
        expect(true).toBe(true);
    });
});
