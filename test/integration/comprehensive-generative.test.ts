import { beforeAll, describe, expect, test } from "vitest";
import { EmptyFileSystem } from "langium";
import { parseHelper } from "langium/test";
import { createMachineServices } from "../../src/language/machine-module.js";
import { Machine, isMachine } from "../../src/language/generated/ast.js";
import { generateJSON, generateGraphviz } from "../../src/language/generator/generator.js";
import { renderDotToSVG } from "../../src/language/diagram/graphviz-generator.js";
import * as fs from "node:fs";
import * as path from "node:path";
import * as crypto from "node:crypto";

// Import the examples list generated by prebuild
import examplesList from "../../src/generated/examples-list.json" assert { type: "json" };

let services: ReturnType<typeof createMachineServices>;
let parse: ReturnType<typeof parseHelper<Machine>>;

beforeAll(async () => {
    services = createMachineServices(EmptyFileSystem);
    parse = parseHelper<Machine>(services.Machine);
});

/**
 * Comprehensive Generative Integration Test Suite
 *
 * This test suite programmatically iterates over ALL extracted examples
 * from the build process and validates:
 * 1. Parsing (no lexer/parser errors)
 * 2. JSON generation (completeness)
 * 3. Graphviz DOT generation (losslessness)
 * 4. SVG rendering (renderability)
 *
 * Examples are loaded from src/generated/examples-list.json which is
 * generated by scripts/prebuild.js from markdown documentation.
 */

interface ValidationResult {
    testName: string;
    category: string;
    path: string;
    source: string;
    passed: boolean;
    parseErrors: string[];
    transformErrors: string[];
    completenessIssues: string[];
    losslessnessIssues: string[];
    graphvizParseErrors: string[];
    svgRenderErrors: string[];
    snapshotMismatches: string[];
    jsonOutput?: any;
    graphvizOutput?: string;
    svgOutput?: string;
}

/**
 * Snapshot Manager
 *
 * Manages snapshot storage, comparison, and updates for test outputs.
 * Snapshots are stored in test/integration/__snapshots__/ and tracked in git.
 */
class SnapshotManager {
    private snapshotDir: string;
    private updateSnapshots: boolean;
    private selectiveUpdate: boolean;
    private allowedFiles: Set<string> | null;

    constructor() {
        this.snapshotDir = path.join(process.cwd(), 'test', 'integration', '__snapshots__');
        // Check for UPDATE_SNAPSHOTS environment variable
        this.updateSnapshots = process.env.UPDATE_SNAPSHOTS === 'true';

        // Check for selective update mode
        this.selectiveUpdate = process.env.SELECTIVE_SNAPSHOT_UPDATE === 'true';
        this.allowedFiles = null;

        if (this.selectiveUpdate && process.env.SNAPSHOT_UPDATE_CONFIG) {
            try {
                const configPath = process.env.SNAPSHOT_UPDATE_CONFIG;
                if (fs.existsSync(configPath)) {
                    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
                    this.allowedFiles = new Set(config.files || []);
                    console.log(`üìã Selective update mode: ${this.allowedFiles.size} file(s) allowed`);
                }
            } catch (e) {
                console.warn(`Failed to load selective update config: ${e}`);
            }
        }

        if (!fs.existsSync(this.snapshotDir)) {
            fs.mkdirSync(this.snapshotDir, { recursive: true });
        }
    }

    /**
     * Get the snapshot file path for a given test
     */
    private getSnapshotPath(testName: string, category: string): string {
        const sanitizedCategory = category.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const sanitizedName = testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        return path.join(this.snapshotDir, `${sanitizedCategory}_${sanitizedName}.json`);
    }

    /**
     * Generate a hash of content for quick comparison
     */
    private hashContent(content: string): string {
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    /**
     * Load existing snapshot for a test, if it exists
     */
    loadSnapshot(testName: string, category: string): any | null {
        const snapshotPath = this.getSnapshotPath(testName, category);
        if (!fs.existsSync(snapshotPath)) {
            return null;
        }
        try {
            const content = fs.readFileSync(snapshotPath, 'utf-8');
            return JSON.parse(content);
        } catch (e) {
            console.warn(`Failed to load snapshot for ${testName}: ${e}`);
            return null;
        }
    }

    /**
     * Save a snapshot for a test
     */
    saveSnapshot(testName: string, category: string, snapshot: any): void {
        const snapshotPath = this.getSnapshotPath(testName, category);
        fs.writeFileSync(snapshotPath, JSON.stringify(snapshot, null, 2), 'utf-8');
    }

    /**
     * Check if a snapshot file is allowed for update in selective mode
     */
    private isAllowedForUpdate(testName: string, category: string): boolean {
        if (!this.selectiveUpdate || !this.allowedFiles) {
            return true; // Not in selective mode, allow all
        }

        const sanitizedCategory = category.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const sanitizedName = testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const baseName = `${sanitizedCategory}_${sanitizedName}`;

        return this.allowedFiles.has(baseName);
    }

    /**
     * Compare current outputs against snapshot and return differences
     */
    compareWithSnapshot(
        testName: string,
        category: string,
        jsonOutput: any,
        graphvizOutput: string,
        svgOutput: string
    ): string[] {
        const differences: string[] = [];
        const snapshot = this.loadSnapshot(testName, category);

        // Determine if we should update this specific snapshot
        const shouldUpdate = this.updateSnapshots && this.isAllowedForUpdate(testName, category);

        if (!snapshot) {
            if (shouldUpdate) {
                // Create new snapshot
                this.saveSnapshot(testName, category, {
                    json: jsonOutput,
                    graphviz: graphvizOutput,
                    svgHash: this.hashContent(svgOutput)
                });
                differences.push('New snapshot created');
            } else {
                differences.push('No baseline snapshot found. Run tests with UPDATE_SNAPSHOTS=true to create snapshots.');
            }
            return differences;
        }

        // Compare JSON output
        const currentJsonStr = JSON.stringify(jsonOutput, null, 2);
        const snapshotJsonStr = JSON.stringify(snapshot.json, null, 2);
        if (currentJsonStr !== snapshotJsonStr) {
            differences.push('JSON output differs from snapshot');
        }

        // Compare Graphviz output
        if (graphvizOutput !== snapshot.graphviz) {
            differences.push('Graphviz DOT output differs from snapshot');
        }

        // Compare SVG output (using hash for efficiency)
        const currentSvgHash = this.hashContent(svgOutput);
        if (currentSvgHash !== snapshot.svgHash) {
            differences.push('SVG output differs from snapshot');
        }

        // Update snapshot if requested and allowed
        if (differences.length > 0 && shouldUpdate) {
            this.saveSnapshot(testName, category, {
                json: jsonOutput,
                graphviz: graphvizOutput,
                svgHash: currentSvgHash
            });
            differences.push('Snapshot updated');
        }

        return differences;
    }

    /**
     * Get all snapshot files
     */
    getAllSnapshots(): string[] {
        if (!fs.existsSync(this.snapshotDir)) {
            return [];
        }
        return fs.readdirSync(this.snapshotDir)
            .filter(file => file.endsWith('.json'))
            .map(file => path.join(this.snapshotDir, file));
    }

    /**
     * Check if snapshots should be updated
     */
    shouldUpdateSnapshots(): boolean {
        return this.updateSnapshots;
    }
}

class ValidationReporter {
    private results: ValidationResult[] = [];
    private outputDir = path.join(process.cwd(), 'test-output', 'comprehensive-generative');

    constructor() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    addResult(result: ValidationResult): void {
        this.results.push(result);

        // Write individual outputs for manual inspection
        const fileName = result.testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        const categoryDir = path.join(this.outputDir, result.category);

        if (!fs.existsSync(categoryDir)) {
            fs.mkdirSync(categoryDir, { recursive: true });
        }

        // Write markdown report
        let mdContent = `# ${result.testName}\n\n`;
        mdContent += `**Category**: ${result.category}\n`;
        mdContent += `**Path**: ${result.path}\n`;
        mdContent += `**Status**: ${result.passed ? '‚úÖ PASSED' : '‚ùå FAILED'}\n\n`;

        mdContent += `## Source\n\`\`\`dygram\n${result.source}\n\`\`\`\n\n`;

        if (result.jsonOutput) {
            mdContent += `## JSON Output\n\`\`\`json\n${JSON.stringify(result.jsonOutput, null, 2)}\n\`\`\`\n\n`;
        }

        if (result.graphvizOutput) {
            mdContent += `## Graphviz DOT Output\n\`\`\`dot\n${result.graphvizOutput}\n\`\`\`\n\n`;
        }

        mdContent += `## Validation Results\n`;
        mdContent += `- Parse Errors: ${result.parseErrors.length}\n`;
        mdContent += `- Transform Errors: ${result.transformErrors.length}\n`;
        mdContent += `- Completeness Issues: ${result.completenessIssues.length}\n`;
        mdContent += `- Losslessness Issues: ${result.losslessnessIssues.length}\n`;
        mdContent += `- Graphviz Parse Errors: ${result.graphvizParseErrors.length}\n`;
        mdContent += `- SVG Render Errors: ${result.svgRenderErrors.length}\n`;
        mdContent += `- Snapshot Mismatches: ${result.snapshotMismatches.length}\n\n`;

        if (result.parseErrors.length > 0) {
            mdContent += `### Parse Errors\n${result.parseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.transformErrors.length > 0) {
            mdContent += `### Transform Errors\n${result.transformErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.completenessIssues.length > 0) {
            mdContent += `### Completeness Issues\n${result.completenessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.losslessnessIssues.length > 0) {
            mdContent += `### Losslessness Issues\n${result.losslessnessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.graphvizParseErrors.length > 0) {
            mdContent += `### Graphviz Parse Errors\n${result.graphvizParseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.svgRenderErrors.length > 0) {
            mdContent += `### SVG Render Errors\n${result.svgRenderErrors.map(e => `- ${e}`).join('\n')}\n\n`;
        }
        if (result.snapshotMismatches.length > 0) {
            mdContent += `### Snapshot Mismatches\n${result.snapshotMismatches.map(e => `- ${e}`).join('\n')}\n\n`;
        }

        fs.writeFileSync(path.join(categoryDir, `${fileName}.md`), mdContent);

        // Write SVG if it was successfully generated
        if (result.svgOutput && result.svgRenderErrors.length === 0) {
            fs.writeFileSync(path.join(categoryDir, `${fileName}.svg`), result.svgOutput);
        }
    }

    generateReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.passed).length;
        const failed = total - passed;

        let report = `# Comprehensive Generative Test Report\n\n`;
        report += `Generated: ${new Date().toISOString()}\n\n`;
        report += `## Summary\n`;
        report += `- Total Tests: ${total}\n`;
        report += `- Passed: ${passed}\n`;
        report += `- Failed: ${failed}\n`;
        report += `- Success Rate: ${((passed / total) * 100).toFixed(2)}%\n\n`;

        // Group by category
        const byCategory: Record<string, { total: number; passed: number }> = {};
        this.results.forEach(r => {
            if (!byCategory[r.category]) {
                byCategory[r.category] = { total: 0, passed: 0 };
            }
            byCategory[r.category].total++;
            if (r.passed) byCategory[r.category].passed++;
        });

        report += `## Results by Category\n`;
        Object.keys(byCategory).sort().forEach(category => {
            const { total, passed } = byCategory[category];
            const rate = ((passed / total) * 100).toFixed(1);
            report += `- **${category}**: ${passed}/${total} (${rate}%)\n`;
        });
        report += `\n`;

        // Group issues by type
        const allParseErrors = this.results.flatMap(r => r.parseErrors);
        const allTransformErrors = this.results.flatMap(r => r.transformErrors);
        const allCompletenessIssues = this.results.flatMap(r => r.completenessIssues);
        const allLosslessnessIssues = this.results.flatMap(r => r.losslessnessIssues);
        const allGraphvizParseErrors = this.results.flatMap(r => r.graphvizParseErrors);
        const allSvgRenderErrors = this.results.flatMap(r => r.svgRenderErrors);
        const allSnapshotMismatches = this.results.flatMap(r => r.snapshotMismatches);

        report += `## Issue Summary\n`;
        report += `- Parse Errors: ${allParseErrors.length}\n`;
        report += `- Transform Errors: ${allTransformErrors.length}\n`;
        report += `- Completeness Issues: ${allCompletenessIssues.length}\n`;
        report += `- Losslessness Issues: ${allLosslessnessIssues.length}\n`;
        report += `- Graphviz Parse Errors: ${allGraphvizParseErrors.length}\n`;
        report += `- SVG Render Errors: ${allSvgRenderErrors.length}\n`;
        report += `- Snapshot Mismatches: ${allSnapshotMismatches.length}\n\n`;

        // Failed tests details
        const failedResults = this.results.filter(r => !r.passed);
        if (failedResults.length > 0) {
            report += `## Failed Tests (${failedResults.length})\n\n`;
            failedResults.forEach(r => {
                report += `### ${r.testName} (${r.category})\n`;
                report += `Path: ${r.path}\n\n`;
                if (r.parseErrors.length > 0) {
                    report += `**Parse Errors:**\n${r.parseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.transformErrors.length > 0) {
                    report += `**Transform Errors:**\n${r.transformErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.completenessIssues.length > 0) {
                    report += `**Completeness Issues:**\n${r.completenessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.losslessnessIssues.length > 0) {
                    report += `**Losslessness Issues:**\n${r.losslessnessIssues.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.graphvizParseErrors.length > 0) {
                    report += `**Graphviz Parse Errors:**\n${r.graphvizParseErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.svgRenderErrors.length > 0) {
                    report += `**SVG Render Errors:**\n${r.svgRenderErrors.map(e => `- ${e}`).join('\n')}\n\n`;
                }
                if (r.snapshotMismatches.length > 0) {
                    report += `**Snapshot Mismatches:**\n${r.snapshotMismatches.map(e => `- ${e}`).join('\n')}\n\n`;
                }
            });
        }

        return report;
    }

    generateHtmlReport(): string {
        const total = this.results.length;
        const passed = this.results.filter(r => r.passed).length;
        const failed = total - passed;
        const successRate = ((passed / total) * 100).toFixed(2);

        const allParseErrors = this.results.flatMap(r => r.parseErrors);
        const allTransformErrors = this.results.flatMap(r => r.transformErrors);
        const allCompletenessIssues = this.results.flatMap(r => r.completenessIssues);
        const allLosslessnessIssues = this.results.flatMap(r => r.losslessnessIssues);
        const allGraphvizParseErrors = this.results.flatMap(r => r.graphvizParseErrors);
        const allSvgRenderErrors = this.results.flatMap(r => r.svgRenderErrors);
        const allSnapshotMismatches = this.results.flatMap(r => r.snapshotMismatches);

        // Group by category
        const byCategory: Record<string, { total: number; passed: number }> = {};
        this.results.forEach(r => {
            if (!byCategory[r.category]) {
                byCategory[r.category] = { total: 0, passed: 0 };
            }
            byCategory[r.category].total++;
            if (r.passed) byCategory[r.category].passed++;
        });

        let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Generative Test Report - DyGram</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; padding: 1rem; }
        .container { max-width: 1600px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 1rem; }
        h1 { color: #667eea; margin-bottom: 0.25rem; font-size: 1.75rem; }
        .subtitle { color: #666; margin-bottom: 1rem; font-size: 0.875rem; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem; }
        .stat-card { padding: 1rem; border-radius: 6px; text-align: center; }
        .stat-card.total { background: #e3f2fd; }
        .stat-card.passed { background: #e8f5e9; }
        .stat-card.failed { background: #ffebee; }
        .stat-value { font-size: 2rem; font-weight: bold; }
        .stat-label { color: #666; font-size: 0.75rem; margin-top: 0.25rem; }
        .issues { margin-bottom: 1.5rem; }
        .issue-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; }
        .issue-card { padding: 0.75rem; border-radius: 4px; background: #f9f9f9; border-left: 4px solid #667eea; }
        .issue-count { font-size: 1.25rem; font-weight: bold; color: #667eea; }
        .issue-label { font-size: 0.75rem; color: #666; }
        .category-section { margin-bottom: 1.5rem; }
        .category-header { background: #f9f9f9; padding: 0.75rem; border-radius: 4px; cursor: pointer; user-select: none; }
        .category-header:hover { background: #f0f0f0; }
        .category-header h3 { display: flex; align-items: center; gap: 0.5rem; font-size: 1.1rem; }
        .category-toggle { display: inline-block; transition: transform 0.2s; }
        .category-toggle.collapsed { transform: rotate(-90deg); }
        .category-stats { display: flex; gap: 0.75rem; align-items: center; margin-top: 0.5rem; font-size: 0.875rem; }
        .category-bar { flex: 1; height: 16px; background: #e0e0e0; border-radius: 8px; overflow: hidden; }
        .category-bar-fill { height: 100%; background: linear-gradient(to right, #4caf50, #8bc34a); transition: width 0.3s; }
        .test-list { margin-top: 0.75rem; display: none; }
        .test-list.expanded { display: block; }
        .test-item { border: 1px solid #e0e0e0; border-radius: 4px; margin-bottom: 0.75rem; overflow: hidden; }
        .test-header { padding: 0.75rem; background: #fafafa; display: flex; justify-content: space-between; align-items: center; cursor: pointer; gap: 0.5rem; flex-wrap: wrap; }
        .test-header:hover { background: #f5f5f5; }
        .test-name { font-weight: 600; font-size: 0.9rem; word-break: break-word; }
        .test-status { padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; white-space: nowrap; }
        .test-status.passed { background: #4caf50; color: white; }
        .test-status.failed { background: #f44336; color: white; }
        .test-status.snapshot-mismatch { background: #ff9800; color: white; }
        .test-details { padding: 1rem; display: none; background: white; border-top: 1px solid #e0e0e0; }
        .test-details.active { display: block; }
        .tabs { display: flex; gap: 0.25rem; margin-bottom: 0.75rem; border-bottom: 2px solid #e0e0e0; flex-wrap: wrap; }
        .tab { padding: 0.5rem 0.75rem; cursor: pointer; background: none; border: none; font-size: 0.8rem; font-weight: 600; color: #666; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab:hover { color: #667eea; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-content h4 { font-size: 1rem; margin-bottom: 0.5rem; }
        .code-block { background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 4px; padding: 0.75rem; overflow-x: auto; font-family: 'Courier New', monospace; font-size: 0.8rem; margin: 0.5rem 0; white-space: pre-wrap; word-break: break-word; }
        .error-section { margin-top: 0.75rem; }
        .error-section h4 { color: #d32f2f; margin-bottom: 0.5rem; font-size: 0.95rem; }
        .warning-section h4 { color: #f57c00; margin-bottom: 0.5rem; font-size: 0.95rem; }
        .error-list { list-style: none; padding-left: 0.75rem; }
        .error-list li { padding: 0.25rem 0; color: #666; font-size: 0.85rem; }
        .error-list li:before { content: "‚ö† "; color: #d32f2f; }
        .warning-list li:before { content: "‚ö† "; color: #f57c00; }
        .svg-container { border: 1px solid #e0e0e0; border-radius: 4px; padding: 0.75rem; background: white; margin: 0.5rem 0; overflow-x: auto; }
        .svg-container svg { max-width: 100%; height: auto; }
        .snapshot-badge { display: inline-block; padding: 0.25rem 0.5rem; background: #ff9800; color: white; font-size: 0.7rem; border-radius: 4px; margin-left: 0.5rem; }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            body { padding: 0.5rem; }
            .container { padding: 0.75rem; border-radius: 4px; }
            h1 { font-size: 1.5rem; }
            .subtitle { font-size: 0.8rem; }
            .summary { grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
            .stat-card { padding: 0.75rem; }
            .stat-value { font-size: 1.5rem; }
            .stat-label { font-size: 0.7rem; }
            .issue-grid { grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
            .issue-card { padding: 0.5rem; }
            .issue-count { font-size: 1.1rem; }
            .issue-label { font-size: 0.7rem; }
            .category-header { padding: 0.5rem; }
            .category-header h3 { font-size: 1rem; }
            .category-stats { font-size: 0.8rem; gap: 0.5rem; }
            .test-header { padding: 0.5rem; }
            .test-name { font-size: 0.85rem; }
            .test-status { font-size: 0.7rem; padding: 0.2rem 0.4rem; }
            .test-details { padding: 0.75rem; }
            .tabs { gap: 0.15rem; }
            .tab { padding: 0.4rem 0.5rem; font-size: 0.75rem; }
            .code-block { padding: 0.5rem; font-size: 0.75rem; }
            .snapshot-badge { font-size: 0.65rem; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.25rem; }
            .summary { grid-template-columns: 1fr; }
            .issue-grid { grid-template-columns: 1fr; }
            .category-bar { height: 12px; }
            .test-name { font-size: 0.8rem; }
        }
    </style>
    <script>
        function toggleCategory(categoryId) {
            const testList = document.getElementById(categoryId);
            const toggle = document.getElementById(categoryId + '-toggle');
            testList.classList.toggle('expanded');
            toggle.classList.toggle('collapsed');
        }
        function toggleDetails(id) {
            const details = document.getElementById(id);
            details.classList.toggle('active');
        }
        function showTab(testId, tabName) {
            const tabs = document.querySelectorAll(\`#\${testId} .tab\`);
            const contents = document.querySelectorAll(\`#\${testId} .tab-content\`);
            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));
            document.querySelector(\`#\${testId} .tab[data-tab="\${tabName}"]\`).classList.add('active');
            document.getElementById(\`\${testId}-\${tabName}\`).classList.add('active');
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>üìä Comprehensive Generative Test Report</h1>
        <p class="subtitle">Complete DyGram transformation pipeline validation with snapshot testing</p>

        <div class="summary">
            <div class="stat-card total">
                <div class="stat-value">${total}</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card passed">
                <div class="stat-value">${passed}</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card failed">
                <div class="stat-value">${failed}</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card total">
                <div class="stat-value">${successRate}%</div>
                <div class="stat-label">Success Rate</div>
            </div>
        </div>

        <div class="issues">
            <h2>Issue Summary</h2>
            <div class="issue-grid">
                <div class="issue-card">
                    <div class="issue-count">${allParseErrors.length}</div>
                    <div class="issue-label">Parse Errors</div>
                </div>
                <div class="issue-card">
                    <div class="issue-count">${allTransformErrors.length}</div>
                    <div class="issue-label">Transform Errors</div>
                </div>
                <div class="issue-card">
                    <div class="issue-count">${allCompletenessIssues.length}</div>
                    <div class="issue-label">Completeness Issues</div>
                </div>
                <div class="issue-card">
                    <div class="issue-count">${allLosslessnessIssues.length}</div>
                    <div class="issue-label">Losslessness Issues</div>
                </div>
                <div class="issue-card">
                    <div class="issue-count">${allGraphvizParseErrors.length}</div>
                    <div class="issue-label">Graphviz Errors</div>
                </div>
                <div class="issue-card">
                    <div class="issue-count">${allSvgRenderErrors.length}</div>
                    <div class="issue-label">SVG Errors</div>
                </div>
                <div class="issue-card" style="border-left-color: #ff9800;">
                    <div class="issue-count" style="color: #ff9800;">${allSnapshotMismatches.length}</div>
                    <div class="issue-label">Snapshot Mismatches</div>
                </div>
            </div>
        </div>

        <h2>Results by Category</h2>`;

        // Category sections
        Object.keys(byCategory).sort().forEach((category, categoryIndex) => {
            const { total: catTotal, passed: catPassed } = byCategory[category];
            const rate = ((catPassed / catTotal) * 100).toFixed(1);
            const categoryResults = this.results.filter(r => r.category === category);
            const categoryId = `category-${categoryIndex}`;

            html += `
        <div class="category-section">
            <div class="category-header" onclick="toggleCategory('${categoryId}')">
                <h3><span class="category-toggle collapsed" id="${categoryId}-toggle">‚ñº</span> ${category}</h3>
                <div class="category-stats">
                    <span>${catPassed}/${catTotal} passed (${rate}%)</span>
                    <div class="category-bar">
                        <div class="category-bar-fill" style="width: ${rate}%"></div>
                    </div>
                </div>
            </div>
            <div class="test-list" id="${categoryId}">`;

            categoryResults.forEach((result, index) => {
                const fileName = result.testName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const detailsId = `details-${category}-${index}`;
                const hasSnapshotMismatch = result.snapshotMismatches.length > 0;
                const statusClass = !result.passed ? 'failed' : hasSnapshotMismatch ? 'snapshot-mismatch' : 'passed';
                const statusText = !result.passed ? 'FAILED' : hasSnapshotMismatch ? 'PASSED' : 'PASSED';

                html += `
                <div class="test-item">
                    <div class="test-header" onclick="toggleDetails('${detailsId}')">
                        <span class="test-name">${result.testName}${hasSnapshotMismatch && result.passed ? '<span class="snapshot-badge">SNAPSHOT INFO</span>' : ''}</span>
                        <span class="test-status ${statusClass}">${statusText}</span>
                    </div>
                    <div class="test-details" id="${detailsId}">
                        <div class="tabs">
                            <button class="tab active" data-tab="source" onclick="showTab('${detailsId}', 'source')">Source</button>
                            <button class="tab" data-tab="json" onclick="showTab('${detailsId}', 'json')">JSON</button>
                            <button class="tab" data-tab="dot" onclick="showTab('${detailsId}', 'dot')">Graphviz DOT</button>
                            <button class="tab" data-tab="svg" onclick="showTab('${detailsId}', 'svg')">SVG</button>
                            ${!result.passed || hasSnapshotMismatch ? '<button class="tab" data-tab="issues" onclick="showTab(\'' + detailsId + '\', \'issues\')">Issues</button>' : ''}
                        </div>

                        <div class="tab-content active" id="${detailsId}-source">
                            <h4>Source Code</h4>
                            <div class="code-block">${this.escapeHtml(result.source)}</div>
                        </div>

                        <div class="tab-content" id="${detailsId}-json">
                            <h4>JSON Output</h4>
                            ${result.jsonOutput ? `<div class="code-block">${this.escapeHtml(JSON.stringify(result.jsonOutput, null, 2))}</div>` : '<p>No JSON output available</p>'}
                        </div>

                        <div class="tab-content" id="${detailsId}-dot">
                            <h4>Graphviz DOT Output</h4>
                            ${result.graphvizOutput ? `<div class="code-block">${this.escapeHtml(result.graphvizOutput)}</div>` : '<p>No DOT output available</p>'}
                        </div>

                        <div class="tab-content" id="${detailsId}-svg">
                            <h4>SVG Rendering</h4>
                            ${result.svgOutput ? `<div class="svg-container">${result.svgOutput}</div>` : '<p>No SVG output available</p>'}
                        </div>`;

                if (!result.passed || hasSnapshotMismatch) {
                    html += `
                        <div class="tab-content" id="${detailsId}-issues">`;

                    if (result.parseErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Parse Errors</h4>
                            <ul class="error-list">${result.parseErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.transformErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Transform Errors</h4>
                            <ul class="error-list">${result.transformErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.completenessIssues.length > 0) {
                        html += `<div class="error-section">
                            <h4>Completeness Issues</h4>
                            <ul class="error-list">${result.completenessIssues.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.losslessnessIssues.length > 0) {
                        html += `<div class="error-section">
                            <h4>Losslessness Issues</h4>
                            <ul class="error-list">${result.losslessnessIssues.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.graphvizParseErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>Graphviz Parse Errors</h4>
                            <ul class="error-list">${result.graphvizParseErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.svgRenderErrors.length > 0) {
                        html += `<div class="error-section">
                            <h4>SVG Render Errors</h4>
                            <ul class="error-list">${result.svgRenderErrors.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }
                    if (result.snapshotMismatches.length > 0) {
                        const isInfoOnly = result.passed;
                        html += `<div class="${isInfoOnly ? 'warning-section' : 'error-section'}">
                            <h4>Snapshot ${isInfoOnly ? 'Information' : 'Mismatches'}</h4>
                            <ul class="error-list ${isInfoOnly ? 'warning-list' : ''}">${result.snapshotMismatches.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}</ul>
                        </div>`;
                    }

                    html += `</div>`;
                }

                html += `
                        <p style="margin-top: 1rem;"><a href="${category}/${fileName}.md" target="_blank">View Markdown Report ‚Üí</a></p>
                    </div>
                </div>`;
            });

            html += `
            </div>
        </div>`;
        });

        html += `
    </div>
</body>
</html>`;

        return html;
    }

    private escapeHtml(text: string): string {
        const map: Record<string, string> = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    writeReport(): void {
        const report = this.generateReport();
        const htmlReport = this.generateHtmlReport();

        fs.writeFileSync(path.join(this.outputDir, 'REPORT.md'), report);
        fs.writeFileSync(path.join(this.outputDir, 'index.html'), htmlReport);

        console.log(`\nüìä Comprehensive test report written to: ${path.join(this.outputDir, 'REPORT.md')}`);
        console.log(`üåê HTML report available at: ${path.join(this.outputDir, 'index.html')}`);
        console.log(`üìÅ Individual test outputs: ${this.outputDir}\n`);
    }
}

describe('Comprehensive Generative Integration Tests', () => {
    const reporter = new ValidationReporter();
    const snapshotManager = new SnapshotManager();

    // Log snapshot mode at the start
    if (snapshotManager.shouldUpdateSnapshots()) {
        console.log('üîÑ Running in SNAPSHOT UPDATE mode. Snapshots will be created/updated.');
    } else {
        console.log('üì∏ Running in SNAPSHOT COMPARISON mode. Tests will fail if outputs differ from snapshots.');
        console.log('üí° To update snapshots, run: UPDATE_SNAPSHOTS=true npm test');
    }

    const runGenerativeTest = async (example: typeof examplesList[0]) => {
        const result: ValidationResult = {
            testName: example.name,
            category: example.category,
            path: example.path,
            source: example.content,
            passed: true,
            parseErrors: [],
            transformErrors: [],
            completenessIssues: [],
            losslessnessIssues: [],
            graphvizParseErrors: [],
            svgRenderErrors: [],
            snapshotMismatches: []
        };

        try {
            // Parse
            const document = await parse(example.content);

            // Check for parse errors
            if (document.parseResult.parserErrors.length > 0) {
                result.parseErrors = document.parseResult.parserErrors.map(e => e.message);
                result.passed = false;
            }

            if (document.parseResult.lexerErrors.length > 0) {
                result.parseErrors.push(...document.parseResult.lexerErrors.map(e => e.message));
                result.passed = false;
            }

            if (!isMachine(document.parseResult.value)) {
                result.parseErrors.push('Parsed value is not a Machine');
                result.passed = false;
                reporter.addResult(result);
                return result;
            }

            const machine = document.parseResult.value as Machine;

            // Transform to JSON
            try {
                const jsonResult = generateJSON(machine, example.filename, undefined);
                result.jsonOutput = JSON.parse(jsonResult.content);

                // Validate completeness: all nodes should be in JSON
                const sourceNodeNames = extractNodeNamesFromSource(example.content);
                const jsonNodeNames = result.jsonOutput.nodes.map((n: any) => n.name);

                for (const nodeName of sourceNodeNames) {
                    if (!jsonNodeNames.includes(nodeName)) {
                        result.completenessIssues.push(`Node "${nodeName}" from source not found in JSON output`);
                        result.passed = false;
                    }
                }

                // Check edge preservation
                const sourceEdgeCount = (example.content.match(/->/g) || []).length +
                                      (example.content.match(/-->/g) || []).length +
                                      (example.content.match(/=>/g) || []).length +
                                      (example.content.match(/<-->/g) || []).length;

                if (sourceEdgeCount > 0 && result.jsonOutput.edges.length === 0) {
                    result.completenessIssues.push(`Source has ${sourceEdgeCount} edges, but JSON has none`);
                    result.passed = false;
                }

            } catch (e) {
                result.transformErrors.push(`JSON generation failed: ${e}`);
                result.passed = false;
            }

            // Transform to Graphviz
            try {
                const graphvizResult = generateGraphviz(machine, example.filename, undefined);
                result.graphvizOutput = graphvizResult.content;

                // Validate Graphviz contains key elements
                if (!result.graphvizOutput.includes('digraph')) {
                    result.losslessnessIssues.push('Graphviz output missing digraph declaration');
                    result.passed = false;
                }

                if (machine.title && !result.graphvizOutput.includes(machine.title)) {
                    result.losslessnessIssues.push(`Graphviz output missing machine title: "${machine.title}"`);
                    result.passed = false;
                }

                // Check that nodes appear in Graphviz
                const sourceNodeNames = extractNodeNamesFromSource(example.content);
                for (const nodeName of sourceNodeNames) {
                    if (!result.graphvizOutput.includes(nodeName)) {
                        result.losslessnessIssues.push(`Node "${nodeName}" not found in Graphviz output`);
                        result.passed = false;
                    }
                }

                // Basic DOT syntax validation
                // Check for balanced braces
                const openBraces = (result.graphvizOutput.match(/\{/g) || []).length;
                const closeBraces = (result.graphvizOutput.match(/\}/g) || []).length;
                if (openBraces !== closeBraces) {
                    result.graphvizParseErrors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
                    result.passed = false;
                }

                // NEW: Render to SVG
                try {
                    result.svgOutput = await renderDotToSVG(result.graphvizOutput);

                    // Validate SVG output
                    if (!result.svgOutput || result.svgOutput.length === 0) {
                        result.svgRenderErrors.push('SVG output is empty');
                        result.passed = false;
                    } else if (!result.svgOutput.includes('<svg')) {
                        result.svgRenderErrors.push('SVG output does not contain <svg> tag');
                        result.passed = false;
                    } else if (!result.svgOutput.includes('</svg>')) {
                        result.svgRenderErrors.push('SVG output is incomplete (missing closing tag)');
                        result.passed = false;
                    }

                    // Basic SVG structure validation
                    if (result.svgOutput) {
                        const svgOpenTags = (result.svgOutput.match(/<svg[^>]*>/g) || []).length;
                        const svgCloseTags = (result.svgOutput.match(/<\/svg>/g) || []).length;
                        if (svgOpenTags !== svgCloseTags) {
                            result.svgRenderErrors.push(`Unbalanced SVG tags: ${svgOpenTags} open, ${svgCloseTags} close`);
                            result.passed = false;
                        }
                    }
                } catch (e) {
                    result.svgRenderErrors.push(`SVG rendering failed: ${e}`);
                    result.passed = false;
                }

            } catch (e) {
                result.transformErrors.push(`Graphviz generation failed: ${e}`);
                result.passed = false;
            }

            // NEW: Snapshot comparison
            // Only compare snapshots if we have all outputs successfully generated
            if (result.jsonOutput && result.graphvizOutput && result.svgOutput) {
                try {
                    const snapshotDifferences = snapshotManager.compareWithSnapshot(
                        example.name,
                        example.category,
                        result.jsonOutput,
                        result.graphvizOutput,
                        result.svgOutput
                    );

                    // Only fail if there are actual differences AND we're not in update mode
                    const actualDifferences = snapshotDifferences.filter(
                        d => !d.includes('snapshot created') && !d.includes('Snapshot updated')
                    );

                    if (actualDifferences.length > 0 && !snapshotManager.shouldUpdateSnapshots()) {
                        // Real mismatches that should fail the test
                        result.snapshotMismatches = snapshotDifferences;
                        result.passed = false;
                    } else if (snapshotDifferences.length > 0) {
                        // Just informational messages (creation/update messages)
                        result.snapshotMismatches = snapshotDifferences;
                    }
                } catch (e) {
                    result.snapshotMismatches.push(`Snapshot comparison failed: ${e}`);
                    result.passed = false;
                }
            }

        } catch (e) {
            result.transformErrors.push(`Unexpected error: ${e}`);
            result.passed = false;
        }

        reporter.addResult(result);
        return result;
    };

    // Helper to extract node names from source
    const extractNodeNamesFromSource = (source: string): string[] => {
        const names: string[] = [];
        const excludedKeywords = ['machine', 'note', 'workflow'];

        // Match simple node declarations: nodeName;
        const simpleMatches = source.matchAll(/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*;/gm);
        for (const match of simpleMatches) {
            if (!excludedKeywords.includes(match[1])) {
                names.push(match[1]);
            }
        }

        // Match typed nodes: type nodeName;
        const typedMatches = source.matchAll(/^\s*(?:task|state|init|context|workflow|Task|State|Init|Context|Input|Result|Concept)\s+([a-zA-Z_][a-zA-Z0-9_]*)/gmi);
        for (const match of typedMatches) {
            names.push(match[1]);
        }

        // Match nodes with attributes: nodeName { ... }
        const attrMatches = source.matchAll(/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\{/gm);
        for (const match of attrMatches) {
            if (!excludedKeywords.includes(match[1])) {
                names.push(match[1]);
            }
        }

        return [...new Set(names)]; // Remove duplicates
    };

    // Generate tests for all examples programmatically
    examplesList.forEach((example) => {
        test(`${example.category}/${example.name}`, async () => {
            const result = await runGenerativeTest(example);
            expect(result.passed).toBe(true);
        });
    });

    // Write report after all tests
    test('Generate Comprehensive Report', () => {
        reporter.writeReport();
        expect(true).toBe(true);
    });
});
